"""
Module de gestion de la base de données des champs lexicaux.
Fournit une interface pour accéder et manipuler les données des champs lexicaux.
"""

import json
import os
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, asdict
import sqlite3
from pathlib import Path
from datetime import datetime


@dataclass
class MotLexical:
    """Représente un mot lexical avec ses caractéristiques."""
    mot: str
    definition: str
    exemple: Optional[str] = None
    categorie: Optional[str] = None
    synonymes: Optional[List[str]] = None
    antonymes: Optional[List[str]] = None
    frequence: Optional[float] = None
    
    def to_dict(self) -> Dict:
        """Convertit l'objet en dictionnaire."""
        return asdict(self)


@dataclass
class ChampLexical:
    """Représente un champ lexical complet."""
    lettres: str  # "Pr", "Se", "Tr", etc.
    nom_complet: str
    description: str
    mots: List[MotLexical]
    date_creation: str
    date_maj: str
    
    def to_dict(self) -> Dict:
        """Convertit l'objet en dictionnaire."""
        return {
            "lettres": self.lettres,
            "nom_complet": self.nom_complet,
            "description": self.description,
            "mots": [mot.to_dict() for mot in self.mots],
            "date_creation": self.date_creation,
            "date_maj": self.date_maj
        }
    
    def get_mots_list(self) -> List[str]:
        """Retourne la liste des mots sous forme de chaînes."""
        return [mot.mot for mot in self.mots]
    
    def get_definitions(self) -> Dict[str, str]:
        """Retourne un dictionnaire mot -> définition."""
        return {mot.mot: mot.definition for mot in self.mots}
    
    def search_mot(self, mot_recherche: str) -> Optional[MotLexical]:
        """Recherche un mot spécifique dans le champ."""
        mot_recherche = mot_recherche.lower().strip()
        for mot in self.mots:
            if mot.mot.lower() == mot_recherche:
                return mot
        return None
    
    def add_mot(self, mot_lexical: MotLexical) -> bool:
        """Ajoute un mot au champ lexical."""
        # Vérifier si le mot existe déjà
        if any(m.mot.lower() == mot_lexical.mot.lower() for m in self.mots):
            return False
        
        self.mots.append(mot_lexical)
        self.date_maj = datetime.now().isoformat()
        return True
    
    def remove_mot(self, mot: str) -> bool:
        """Supprime un mot du champ lexical."""
        mot = mot.lower().strip()
        initial_count = len(self.mots)
        self.mots = [m for m in self.mots if m.mot.lower() != mot]
        
        if len(self.mots) < initial_count:
            self.date_maj = datetime.now().isoformat()
            return True
        return False


class LexicalFieldDB:
    """Classe principale pour gérer la base de données des champs lexicaux."""
    
    def __init__(self, db_path: str = "data/champs_lexicaux.db", 
                 json_backup_path: str = "data/champs_lexicaux.json"):
        """
        Initialise la base de données.
        
        Args:
            db_path: Chemin vers la base de données SQLite
            json_backup_path: Chemin vers le fichier JSON de sauvegarde
        """
        self.db_path = db_path
        self.json_backup_path = json_backup_path
        self.conn = None
        self._init_database()
        self._ensure_data_loaded()
    
    def _init_database(self) -> None:
        """Initialise la structure de la base de données."""
        # Créer le répertoire data s'il n'existe pas
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Créer les tables
        cursor = self.conn.cursor()
        
        # Table pour les champs lexicaux
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS champs_lexicaux (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                lettres TEXT UNIQUE NOT NULL,
                nom_complet TEXT NOT NULL,
                description TEXT,
                date_creation TEXT NOT NULL,
                date_maj TEXT NOT NULL
            )
        ''')
        
        # Table pour les mots lexicaux
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS mots_lexicaux (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                champ_id INTEGER NOT NULL,
                mot TEXT NOT NULL,
                definition TEXT NOT NULL,
                exemple TEXT,
                categorie TEXT,
                synonymes TEXT,  # Stocké comme JSON array
                antonymes TEXT,   # Stocké comme JSON array
                frequence REAL,
                FOREIGN KEY (champ_id) REFERENCES champs_lexicaux (id),
                UNIQUE(champ_id, mot)
            )
        ''')
        
        # Index pour les recherches
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_mot ON mots_lexicaux(mot)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_champ ON mots_lexicaux(champ_id)')
        
        self.conn.commit()
    
    def _ensure_data_loaded(self) -> None:
        """S'assure que les données sont chargées dans la base de données."""
        cursor = self.conn.cursor()
        
        # Vérifier si la base de données est vide
        cursor.execute('SELECT COUNT(*) as count FROM champs_lexicaux')
        if cursor.fetchone()['count'] == 0:
            # Charger les données initiales depuis le JSON
            self._load_initial_data()
    
    def _load_initial_data(self) -> None:
        """Charge les données initiales depuis le JSON."""
        import json
        from pathlib import Path
        
        json_path = Path(self.json_backup_path)
        
        if json_path.exists():
            # Charger depuis le JSON existant
            with open(json_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            for champ_data in data:
                self.add_champ_from_dict(champ_data)
        else:
            # Créer les données initiales à partir des données fournies
            self._create_initial_data()
    
    def _create_initial_data(self) -> None:
        """Crée les données initiales à partir des données fournies."""
        # Données initiales basées sur votre demande
        champs_data = [
            {
                "lettres": "Pr",
                "nom_complet": "Champ lexical Pr",
                "description": "Mots commençant par 'Pr'",
                "mots": [
                    {"mot": "Précision", "definition": "le fait de donner des détails exacts et précis sur quelque chose."},
                    {"mot": "Profond", "definition": "qui se rapporte à la profondeur ou à une intensité importante."},
                    {"mot": "Profession", "definition": "domaine d'activité ou métier dans lequel une personne travaille."},
                    {"mot": "Progrès", "definition": "avancement ou amélioration dans une situation ou un domaine."},
                    {"mot": "Promesse", "definition": "engagement ou parole donnée de faire quelque chose."},
                    {"mot": "Proverbe", "definition": "expression populaire qui contient une sagesse ou un conseil."},
                    {"mot": "Précieux", "definition": "qui a une grande valeur ou importance."},
                    {"mot": "Préparation", "definition": "action de se préparer ou de s'organiser en vue d'une certaine activité."},
                    {"mot": "Précaution", "definition": "mesure prise pour éviter un danger ou un problème."},
                    {"mot": "Privilège", "definition": "avantage ou droit spécial accordé à certaines personnes."}
                ]
            },
            {
                "lettres": "Se",
                "nom_complet": "Champ lexical Se",
                "description": "Mots commençant par 'Se'",
                "mots": [
                    {"mot": "Sensation", "definition": "perception ou ressenti d'un stimulus par les sens."},
                    {"mot": "Séduction", "definition": "charme ou pouvoir d'attraction envers quelqu'un."},
                    {"mot": "Sérénité", "definition": "état de calme et de tranquillité."},
                    {"mot": "Secret", "definition": "quelque chose qui est caché ou inconnu du public."},
                    {"mot": "Séparation", "definition": "acte de se séparer ou de se diviser."},
                    {"mot": "Sérieux", "definition": "état de responsabilité et de gravité."},
                    {"mot": "Sentiment", "definition": "émotion ou affection ressentie envers quelqu'un ou quelque chose."},
                    {"mot": "Service", "definition": "action d'aider ou d'assister quelqu'un."},
                    {"mot": "Seconde", "definition": "unité de temps ou rang après la première."},
                    {"mot": "Septième", "definition": "ordre ou position dans une série après le sixième."}
                ]
            }
            # Les autres champs seraient ajoutés de manière similaire
        ]
        
        for champ_data in champs_data:
            self.add_champ_from_dict(champ_data)
        
        # Sauvegarder en JSON
        self.export_to_json(self.json_backup_path)
    
    def add_champ_from_dict(self, champ_data: Dict) -> bool:
        """
        Ajoute un champ lexical à partir d'un dictionnaire.
        
        Args:
            champ_data: Dictionnaire contenant les données du champ
            
        Returns:
            True si l'ajout a réussi, False sinon
        """
        try:
            cursor = self.conn.cursor()
            
            # Insérer le champ lexical
            now = datetime.now().isoformat()
            cursor.execute('''
                INSERT OR REPLACE INTO champs_lexicaux 
                (lettres, nom_complet, description, date_creation, date_maj)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                champ_data['lettres'],
                champ_data.get('nom_complet', f"Champ lexical {champ_data['lettres']}"),
                champ_data.get('description', ''),
                now,
                now
            ))
            
            champ_id = cursor.lastrowid
            
            # Insérer les mots
            for mot_data in champ_data.get('mots', []):
                mot_obj = MotLexical(
                    mot=mot_data['mot'],
                    definition=mot_data['definition'],
                    exemple=mot_data.get('exemple'),
                    categorie=mot_data.get('categorie'),
                    synonymes=mot_data.get('synonymes'),
                    antonymes=mot_data.get('antonymes'),
                    frequence=mot_data.get('frequence')
                )
                
                self._add_mot_to_db(cursor, champ_id, mot_obj)
            
            self.conn.commit()
            return True
            
        except Exception as e:
            print(f"Erreur lors de l'ajout du champ: {e}")
            self.conn.rollback()
            return False
    
    def _add_mot_to_db(self, cursor, champ_id: int, mot_lexical: MotLexical) -> None:
        """Ajoute un mot à la base de données."""
        cursor.execute('''
            INSERT OR REPLACE INTO mots_lexicaux 
            (champ_id, mot, definition, exemple, categorie, synonymes, antonymes, frequence)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            champ_id,
            mot_lexical.mot,
            mot_lexical.definition,
            mot_lexical.exemple,
            mot_lexical.categorie,
            json.dumps(mot_lexical.synonymes) if mot_lexical.synonymes else None,
            json.dumps(mot_lexical.antonymes) if mot_lexical.antonymes else None,
            mot_lexical.frequence
        ))
    
    def get_all_champs(self) -> List[ChampLexical]:
        """
        Récupère tous les champs lexicaux.
        
        Returns:
            Liste de tous les champs lexicaux
        """
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT * FROM champs_lexicaux ORDER BY lettres
        ''')
        
        champs = []
        for row in cursor.fetchall():
            champ = self._row_to_champ(row)
            if champ:
                champs.append(champ)
        
        return champs
    
    def get_field(self, lettres: str) -> Optional[ChampLexical]:
        """
        Récupère un champ lexical spécifique.
        
        Args:
            lettres: Les lettres du champ (ex: "Pr", "Se")
            
        Returns:
            Le champ lexical ou None s'il n'existe pas
        """
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT * FROM champs_lexicaux WHERE lettres = ?
        ''', (lettres.upper(),))
        
        row = cursor.fetchone()
        if row:
            return self._row_to_champ(row)
        return None
    
    def _row_to_champ(self, row) -> Optional[ChampLexical]:
        """Convertit une ligne de base de données en objet ChampLexical."""
        champ_id = row['id']
        
        # Récupérer les mots associés
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT * FROM mots_lexicaux WHERE champ_id = ? ORDER BY mot
        ''', (champ_id,))
        
        mots = []
        for mot_row in cursor.fetchall():
            mot = MotLexical(
                mot=mot_row['mot'],
                definition=mot_row['definition'],
                exemple=mot_row['exemple'],
                categorie=mot_row['categorie'],
                synonymes=json.loads(mot_row['synonymes']) if mot_row['synonymes'] else None,
                antonymes=json.loads(mot_row['antonymes']) if mot_row['antonymes'] else None,
                frequence=mot_row['frequence']
            )
            mots.append(mot)
        
        return ChampLexical(
            lettres=row['lettres'],
            nom_complet=row['nom_complet'],
            description=row['description'],
            mots=mots,
            date_creation=row['date_creation'],
            date_maj=row['date_maj']
        )
    
    def search_mot(self, mot_recherche: str) -> List[Dict[str, Any]]:
        """
        Recherche un mot dans tous les champs lexicaux.
        
        Args:
            mot_recherche: Le mot à rechercher
            
        Returns:
            Liste des occurrences avec leur champ lexical
        """
        cursor = self.conn.cursor()
        mot_recherche = f"%{mot_recherche.lower()}%"
        
        cursor.execute('''
            SELECT m.*, c.lettres, c.nom_complet 
            FROM mots_lexicaux m
            JOIN champs_lexicaux c ON m.champ_id = c.id
            WHERE LOWER(m.mot) LIKE ? OR LOWER(m.definition) LIKE ?
            ORDER BY m.mot
        ''', (mot_recherche, mot_recherche))
        
        results = []
        for row in cursor.fetchall():
            result = {
                'mot': row['mot'],
                'definition': row['definition'],
                'champ_lettres': row['lettres'],
                'champ_nom': row['nom_complet'],
                'exemple': row['exemple'],
                'categorie': row['categorie'],
                'synonymes': json.loads(row['synonymes']) if row['synonymes'] else [],
                'antonymes': json.loads(row['antonymes']) if row['antonymes'] else [],
                'frequence': row['frequence']
            }
            results.append(result)
        
        return results
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Calcule des statistiques sur la base de données.
        
        Returns:
            Dictionnaire contenant les statistiques
        """
        cursor = self.conn.cursor()
        
        # Nombre total de champs
        cursor.execute('SELECT COUNT(*) as count FROM champs_lexicaux')
        total_champs = cursor.fetchone()['count']
        
        # Nombre total de mots
        cursor.execute('SELECT COUNT(*) as count FROM mots_lexicaux')
        total_mots = cursor.fetchone()['count']
        
        # Nombre moyen de mots par champ
        cursor.execute('SELECT lettres, COUNT(m.id) as nb_mots FROM champs_lexicaux c LEFT JOIN mots_lexicaux m ON c.id = m.champ_id GROUP BY c.id')
        champs_stats = cursor.fetchall()
        
        moy_mots_par_champ = total_mots / total_champs if total_champs > 0 else 0
        
        # Champ avec le plus de mots
        max_mots = max([row['nb_mots'] for row in champs_stats]) if champs_stats else 0
        champs_max_mots = [row['lettres'] for row in champs_stats if row['nb_mots'] == max_mots]
        
        # Distribution par catégorie (si disponible)
        cursor.execute('SELECT categorie, COUNT(*) as count FROM mots_lexicaux WHERE categorie IS NOT NULL GROUP BY categorie')
        categories = cursor.fetchall()
        
        return {
            'total_champs': total_champs,
            'total_mots': total_mots,
            'moyenne_mots_par_champ': round(moy_mots_par_champ, 2),
            'champ_plus_riche': champs_max_mots[0] if champs_max_mots else None,
            'max_mots_dans_champ': max_mots,
            'distribution_categories': {row['categorie']: row['count'] for row in categories},
            'date_generation': datetime.now().isoformat()
        }
    
    def add_mot_to_champ(self, lettres: str, mot_lexical: MotLexical) -> bool:
        """
        Ajoute un mot à un champ lexical existant.
        
        Args:
            lettres: Les lettres du champ
            mot_lexical: Le mot à ajouter
            
        Returns:
            True si l'ajout a réussi, False sinon
        """
        try:
            cursor = self.conn.cursor()
            
            # Trouver l'ID du champ
            cursor.execute('SELECT id FROM champs_lexicaux WHERE lettres = ?', (lettres.upper(),))
            row = cursor.fetchone()
            
            if not row:
                return False
            
            champ_id = row['id']
            
            # Ajouter le mot
            self._add_mot_to_db(cursor, champ_id, mot_lexical)
            
            # Mettre à jour la date de modification du champ
            now = datetime.now().isoformat()
            cursor.execute('UPDATE champs_lexicaux SET date_maj = ? WHERE id = ?', (now, champ_id))
            
            self.conn.commit()
            return True
            
        except Exception as e:
            print(f"Erreur lors de l'ajout du mot: {e}")
            self.conn.rollback()
            return False
    
    def export_to_json(self, filepath: str) -> bool:
        """
        Exporte toute la base de données vers un fichier JSON.
        
        Args:
            filepath: Chemin du fichier JSON
            
        Returns:
            True si l'export a réussi, False sinon
        """
        try:
            champs = self.get_all_champs()
            data = [champ.to_dict() for champ in champs]
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            return True
        except Exception as e:
            print(f"Erreur lors de l'export JSON: {e}")
            return False
    
    def import_from_json(self, filepath: str) -> bool:
        """
        Importe des données depuis un fichier JSON.
        
        Args:
            filepath: Chemin du fichier JSON
            
        Returns:
            True si l'import a réussi, False sinon
        """
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Vider les tables existantes
            cursor = self.conn.cursor()
            cursor.execute('DELETE FROM mots_lexicaux')
            cursor.execute('DELETE FROM champs_lexicaux')
            
            # Ajouter chaque champ
            for champ_data in data:
                self.add_champ_from_dict(champ_data)
            
            self.conn.commit()
            return True
            
        except Exception as e:
            print(f"Erreur lors de l'import JSON: {e}")
            self.conn.rollback()
            return False
    
    def backup(self, backup_dir: str = "backups") -> Optional[str]:
        """
        Crée une sauvegarde de la base de données.
        
        Args:
            backup_dir: Répertoire de sauvegarde
            
        Returns:
            Chemin du fichier de sauvegarde ou None en cas d'erreur
        """
        try:
            os.makedirs(backup_dir, exist_ok=True)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = os.path.join(backup_dir, f"champs_lexicaux_backup_{timestamp}.db")
            
            # Fermer la connexion actuelle
            if self.conn:
                self.conn.close()
            
            # Copier le fichier de base de données
            import shutil
            shutil.copy2(self.db_path, backup_path)
            
            # Rétablir la connexion
            self.conn = sqlite3.connect(self.db_path)
            self.conn.row_factory = sqlite3.Row
            
            return backup_path
            
        except Exception as e:
            print(f"Erreur lors de la sauvegarde: {e}")
            return None
    
    def get_words_by_length(self, min_length: int = 0, max_length: Optional[int] = None) -> List[Dict]:
        """
        Récupère les mots par longueur.
        
        Args:
            min_length: Longueur minimale
            max_length: Longueur maximale (optionnelle)
            
        Returns:
            Liste des mots avec leurs informations
        """
        cursor = self.conn.cursor()
        
        query = '''
            SELECT m.*, c.lettres, c.nom_complet 
            FROM mots_lexicaux m
            JOIN champs_lexicaux c ON m.champ_id = c.id
            WHERE LENGTH(m.mot) >= ?
        '''
        params = [min_length]
        
        if max_length is not None:
            query += ' AND LENGTH(m.mot) <= ?'
            params.append(max_length)
        
        query += ' ORDER BY LENGTH(m.mot), m.mot'
        
        cursor.execute(query, params)
        
        results = []
        for row in cursor.fetchall():
            result = {
                'mot': row['mot'],
                'longueur': len(row['mot']),
                'definition': row['definition'],
                'champ_lettres': row['lettres'],
                'champ_nom': row['nom_complet'],
                'exemple': row['exemple']
            }
            results.append(result)
        
        return results
    
    def get_champs_by_word_count(self, min_words: int = 0, max_words: Optional[int] = None) -> List[Dict]:
        """
        Récupère les champs par nombre de mots.
        
        Args:
            min_words: Nombre minimum de mots
            max_words: Nombre maximum de mots (optionnel)
            
        Returns:
            Liste des champs avec leur nombre de mots
        """
        cursor = self.conn.cursor()
        
        query = '''
            SELECT c.lettres, c.nom_complet, COUNT(m.id) as nb_mots
            FROM champs_lexicaux c
            LEFT JOIN mots_lexicaux m ON c.id = m.champ_id
            GROUP BY c.id
            HAVING COUNT(m.id) >= ?
        '''
        params = [min_words]
        
        if max_words is not None:
            query += ' AND COUNT(m.id) <= ?'
            params.append(max_words)
        
        query += ' ORDER BY nb_mots DESC'
        
        cursor.execute(query, params)
        
        results = []
        for row in cursor.fetchall():
            result = {
                'lettres': row['lettres'],
                'nom_complet': row['nom_complet'],
                'nb_mots': row['nb_mots']
            }
            results.append(result)
        
        return results
    
    def close(self) -> None:
        """Ferme la connexion à la base de données."""
        if self.conn:
            self.conn.close()
    
    def __enter__(self):
        """Support du contexte manager."""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Ferme la connexion à la sortie du contexte."""
        self.close()


# Fonctions utilitaires
def create_complete_database() -> LexicalFieldDB:
    """
    Crée une base de données complète avec tous les champs lexicaux fournis.
    
    Returns:
        Instance de LexicalFieldDB avec toutes les données
    """
    db = LexicalFieldDB()
    
    # Liste complète des champs lexicaux (abrégée pour l'exemple)
    all_champs = [
        {
            "lettres": "Pr",
            "nom_complet": "Champ lexical Pr",
            "description": "Mots avec le radical 'Pr'",
            "mots": [
                {"mot": "Précision", "definition": "le fait de donner des détails exacts et précis sur quelque chose."},
                {"mot": "Profond", "definition": "qui se rapporte à la profondeur ou à une intensité importante."},
                {"mot": "Profession", "definition": "domaine d'activité ou métier dans lequel une personne travaille."},
                {"mot": "Progrès", "definition": "avancement ou amélioration dans une situation ou un domaine."},
                {"mot": "Promesse", "definition": "engagement ou parole donnée de faire quelque chose."},
                {"mot": "Proverbe", "definition": "expression populaire qui contient une sagesse ou un conseil."},
                {"mot": "Précieux", "definition": "qui a une grande valeur ou importance."},
                {"mot": "Préparation", "definition": "action de se préparer ou de s'organiser en vue d'une certaine activité."},
                {"mot": "Précaution", "definition": "mesure prise pour éviter un danger ou un problème."},
                {"mot": "Privilège", "definition": "avantage ou droit spécial accordé à certaines personnes."}
            ]
        },
        # Ajouter les autres champs de la même manière...
    ]
    
    # Ajouter tous les champs
    for champ_data in all_champs:
        db.add_champ_from_dict(champ_data)
    
    return db


if __name__ == "__main__":
    # Exemple d'utilisation
    db = LexicalFieldDB()
    
    # Afficher tous les champs
    champs = db.get_all_champs()
    print(f"Nombre de champs lexicaux: {len(champs)}")
    
    # Afficher un champ spécifique
    champ_pr = db.get_field("Pr")
    if champ_pr:
        print(f"\nChamp 'Pr': {champ_pr.nom_complet}")
        print(f"Nombre de mots: {len(champ_pr.mots)}")
        print("Mots:", ", ".join(champ_pr.get_mots_list()))
    
    # Statistiques
    stats = db.get_statistics()
    print(f"\nStatistiques:")
    print(f"Total mots: {stats['total_mots']}")
    print(f"Moyenne mots par champ: {stats['moyenne_mots_par_champ']}")
    
    # Sauvegarde
    db.export_to_json("data/export_complet.json")
    print("\nExport JSON effectué: data/export_complet.json")
    
    db.close()