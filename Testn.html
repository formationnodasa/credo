

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quiz Multijoueur - Temps R√©el Parfait</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&family=Montserrat:wght@900&display=swap" rel="stylesheet">
    <style>
        /* RESET COMPLET */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #f59e0b;
            --success: #10b981;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f9fafb;
            --gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            --gradient-hot: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%);
            --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-danger: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
            padding: 20px;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* PARTICULES ANIM√âES */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        /* CONTAINER PRINCIPAL */
        .container {
            max-width: 500px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        /* STATUT CONNEXION */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: var(--dark);
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: slideDown 0.5s ease;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .status-dot.offline {
            background: var(--danger);
            animation: none;
        }

        .status-dot.syncing {
            background: var(--secondary);
            animation: pulse 1s infinite;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        /* √âCRANS */
        .screen {
            display: none;
            padding: 30px;
            min-height: 85vh;
        }

        .screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* LOGO ANIM√â */
        .logo {
            text-align: center;
            margin: 30px 0 50px;
            animation: bounce 2s infinite;
        }

        .logo h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #fff, #f59e0b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
        }

        .logo .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 500;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-15px) scale(1.05); }
        }

        /* BOUTONS */
        .btn {
            display: block;
            width: 100%;
            padding: 20px;
            border: none;
            border-radius: 20px;
            font-family: 'Poppins', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: var(--gradient-hot);
            color: white;
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.4);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(245, 158, 11, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn i {
            margin-right: 10px;
        }

        /* STATS */
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 40px;
        }

        .stat {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            animation: pulseGlow 3s infinite;
        }

        .stat:hover {
            transform: scale(1.05);
        }

        .stat i {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--secondary);
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.2); }
            50% { box-shadow: 0 0 40px rgba(245, 158, 11, 0.4); }
        }

        /* CODE SALLE */
        .room-code {
            background: rgba(255, 255, 255, 0.15);
            padding: 30px;
            border-radius: 25px;
            text-align: center;
            margin: 30px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: codePulse 2s infinite;
        }

        @keyframes codePulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(245, 158, 11, 0.6);
                transform: scale(1.02);
            }
        }

        .code-label {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 15px;
        }

        .code-value {
            font-family: 'Montserrat', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 5px;
            color: var(--secondary);
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            margin: 20px 0;
            animation: textGlow 2s infinite alternate;
        }

        @keyframes textGlow {
            from { text-shadow: 0 0 10px rgba(245, 158, 11, 0.5); }
            to { text-shadow: 0 0 20px rgba(245, 158, 11, 0.8); }
        }

        /* SELECTION QUESTIONS */
        .question-selection {
            background: rgba(255, 255, 255, 0.15);
            padding: 25px;
            border-radius: 25px;
            margin: 25px 0;
            backdrop-filter: blur(10px);
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .question-btn {
            padding: 15px 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: white;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px) scale(1.05);
        }

        .question-btn.selected {
            background: var(--gradient);
            border-color: transparent;
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
            transform: scale(1.1);
            animation: selectedPulse 2s infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4); }
            50% { box-shadow: 0 5px 30px rgba(99, 102, 241, 0.6); }
        }

        /* LISTE JOUEURS */
        .players-list {
            background: rgba(255, 255, 255, 0.15);
            padding: 25px;
            border-radius: 25px;
            margin: 25px 0;
            backdrop-filter: blur(10px);
        }

        .player {
            display: flex;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin: 10px 0;
            transition: all 0.3s ease;
            animation: slideInLeft 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .player:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .player:hover:before {
            left: 100%;
        }

        .player:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(10px) scale(1.02);
        }

        .player.host {
            background: linear-gradient(45deg, rgba(245, 158, 11, 0.2), rgba(239, 68, 68, 0.2));
            border-left: 5px solid var(--secondary);
        }

        .player.answered {
            background: linear-gradient(45deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.2));
            border-left: 5px solid var(--success);
        }

        .player i {
            font-size: 1.5rem;
            margin-right: 15px;
            color: var(--secondary);
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* FORMULAIRES */
        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .form-control {
            width: 100%;
            padding: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: white;
            font-family: 'Poppins', sans-serif;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--secondary);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
            transform: translateY(-2px);
        }

        .form-control::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* TIMER PARFAIT */
        .timer-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto;
        }

        .timer-svg {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }

        .timer-circle-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 8;
        }

        .timer-circle {
            fill: none;
            stroke: var(--secondary);
            stroke-width: 8;
            stroke-linecap: round;
            stroke-dasharray: 377;
            stroke-dashoffset: 377;
            transition: stroke-dashoffset 1s linear;
        }

        .timer-circle.warning {
            stroke: var(--danger);
        }

        .timer-circle.critical {
            stroke: var(--danger);
            animation: pulseCritical 1s infinite;
        }

        @keyframes pulseCritical {
            0%, 100% { stroke-width: 8; }
            50% { stroke-width: 10; }
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .timer-text.warning {
            color: var(--secondary);
            animation: pulseWarning 1s infinite;
        }

        .timer-text.critical {
            color: var(--danger);
            animation: pulseCriticalText 0.5s infinite;
        }

        @keyframes pulseWarning {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes pulseCriticalText {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* QUESTION */
        .question-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 30px;
            border-radius: 25px;
            margin: 25px 0;
            backdrop-filter: blur(10px);
            animation: slideUp 0.5s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .question-card:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: var(--gradient-hot);
            animation: progressBar 12s linear forwards;
        }

        @keyframes progressBar {
            from { width: 100%; }
            to { width: 0%; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .question-prefix {
            font-size: 1.3rem;
            color: var(--secondary);
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .question-text {
            font-size: 1.8rem;
            font-weight: 700;
            line-height: 1.4;
            margin-bottom: 20px;
            text-align: center;
        }

        .question-hint {
            font-size: 1.1rem;
            opacity: 0.9;
            font-style: italic;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            text-align: center;
            animation: hintFade 0.5s ease;
        }

        @keyframes hintFade {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* R√âPONSE */
        .answer-input-container {
            display: flex;
            gap: 15px;
            margin: 25px 0;
        }

        .answer-input {
            flex: 1;
            padding: 18px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: white;
            font-family: 'Poppins', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .answer-input:focus {
            outline: none;
            border-color: var(--secondary);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
            transform: translateY(-2px);
        }

        .answer-input.correct {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
            animation: correctShake 0.5s;
        }

        .answer-input.incorrect {
            border-color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
            animation: incorrectShake 0.5s;
        }

        @keyframes correctShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* BOUTONS RAPIDES */
        .quick-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .quick-btn {
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px) scale(1.05);
        }

        /* CLASSEMENT */
        .scoreboard {
            background: rgba(255, 255, 255, 0.15);
            padding: 25px;
            border-radius: 25px;
            margin: 25px 0;
            backdrop-filter: blur(10px);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin: 10px 0;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .score-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 5px;
            height: 100%;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .score-item:hover:before {
            opacity: 1;
        }

        .score-item.current {
            background: linear-gradient(45deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
            border-left: 5px solid var(--primary);
            transform: scale(1.02);
        }

        .score-item.leading {
            background: linear-gradient(45deg, rgba(245, 158, 11, 0.2), rgba(239, 68, 68, 0.2));
            border-left: 5px solid var(--secondary);
            animation: leaderGlow 2s infinite alternate;
        }

        @keyframes leaderGlow {
            from { box-shadow: 0 0 10px rgba(245, 158, 11, 0.3); }
            to { box-shadow: 0 0 20px rgba(245, 158, 11, 0.6); }
        }

        .player-rank {
            font-weight: 900;
            font-size: 1.5rem;
            color: var(--secondary);
            min-width: 40px;
            text-align: center;
        }

        .player-name {
            flex: 1;
            font-weight: 600;
            font-size: 1.2rem;
            padding: 0 15px;
        }

        .player-score {
            font-weight: 900;
            font-size: 1.5rem;
            color: var(--secondary);
            min-width: 80px;
            text-align: right;
        }

        .score-change {
            font-size: 0.9rem;
            font-weight: 700;
            margin-left: 10px;
            animation: scoreChange 0.5s ease;
        }

        .score-change.positive {
            color: var(--success);
        }

        .score-change.negative {
            color: var(--danger);
        }

        @keyframes scoreChange {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* NOTIFICATIONS */
        .notification {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            color: var(--dark);
            padding: 20px 25px;
            border-radius: 20px;
            max-width: 350px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideInRight 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border-left: 5px solid var(--secondary);
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        /* VOICE INDICATOR */
        .voice-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: var(--dark);
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: slideDown 0.5s ease;
        }

        .voice-indicator i {
            color: var(--primary);
            animation: voicePulse 2s infinite;
        }

        @keyframes voicePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* SYNC INDICATOR */
        .sync-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: var(--dark);
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.5s ease;
        }

        .sync-indicator i {
            color: var(--secondary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* RESPONSIVE */
        @media (max-width: 600px) {
            .container {
                max-width: 100%;
                border-radius: 20px;
            }
            
            .screen {
                padding: 20px;
            }
            
            .logo h1 {
                font-size: 2.5rem;
            }
            
            .question-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .code-value {
                font-size: 3rem;
            }
            
            .answer-input-container {
                flex-direction: column;
            }
            
            .btn {
                padding: 18px;
            }
            
            .timer-container {
                width: 100px;
                height: 100px;
            }
            
            .timer-text {
                font-size: 2.5rem;
            }
            
            .question-text {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 400px) {
            .connection-status, .voice-indicator, .sync-indicator {
                font-size: 0.9rem;
                padding: 8px 15px;
            }
            
            .logo h1 {
                font-size: 2rem;
            }
            
            .code-value {
                font-size: 2.5rem;
            }
        }

        /* ANIMATIONS SUPPL√âMENTAIRES */
        .animate-float {
            animation: float 6s ease-in-out infinite;
        }

        .animate-pulse {
            animation: pulse 2s infinite;
        }

        .animate-bounce {
            animation: bounce 0.5s;
        }

        .fade-out {
            animation: fadeOut 0.3s ease forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: translateY(-20px); }
        }

        /* LOADING */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 50px;
            text-align: center;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--secondary);
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        /* TRANSITIONS */
        .fade-enter {
            opacity: 0;
            transform: translateY(20px);
        }

        .fade-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s ease;
        }

        .fade-exit {
            opacity: 1;
            transform: translateY(0);
        }

        .fade-exit-active {
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- PARTICULES ANIM√âES -->
    <div class="particles" id="particles"></div>
    
    <!-- INDICATEURS -->
    <div class="connection-status">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Synchronisation...</span>
    </div>

    <div class="voice-indicator" id="voiceIndicator" style="display: none;">
        <i class="fas fa-volume-up"></i>
        <span>Vocal actif</span>
    </div>

    <div class="sync-indicator" id="syncIndicator" style="display: none;">
        <i class="fas fa-sync-alt"></i>
        <span>Sync en cours...</span>
    </div>

    <!-- CONTAINER PRINCIPAL -->
    <div class="container">
        <!-- √âCRAN D'ACCUEIL -->
        <div id="homeScreen" class="screen active">
            <div class="logo animate-float">
                <h1>üß† QUIZ SYNC</h1>
                <p class="subtitle">Temps r√©el parfait ‚Ä¢ Synchro audio</p>
            </div>
            
            <div class="button-group">
                <button id="createRoomBtn" class="btn btn-primary">
                    <i class="fas fa-plus-circle"></i> Cr√©er une salle
                </button>
                <button id="joinRoomBtn" class="btn btn-secondary">
                    <i class="fas fa-door-open"></i> Rejoindre
                </button>
            </div>

            <div class="stats">
                <div class="stat">
                    <i class="fas fa-users"></i>
                    <div class="stat-value" id="onlineCount">0</div>
                    <div class="stat-label">Connect√©s</div>
                </div>
                <div class="stat">
                    <i class="fas fa-trophy"></i>
                    <div class="stat-value" id="gamesPlayed">0</div>
                    <div class="stat-label">Parties</div>
                </div>
            </div>
        </div>

        <!-- √âCRAN CR√âATION SALLE -->
        <div id="createScreen" class="screen">
            <div style="margin-bottom: 30px;">
                <button class="btn btn-secondary" id="backFromCreate">
                    <i class="fas fa-arrow-left"></i> Retour
                </button>
                <h2 style="text-align: center; margin: 20px 0; font-size: 2rem; color: var(--secondary);">
                    <i class="fas fa-crown"></i> Cr√©er une salle
                </h2>
            </div>
            
            <div class="room-code">
                <div class="code-label">CODE DE LA SALLE</div>
                <div class="code-value" id="roomCode">-----</div>
                <button class="btn btn-primary" id="copyCodeBtn" style="width: auto; margin: 0 auto;">
                    <i class="fas fa-copy"></i> Copier
                </button>
            </div>

            <div class="question-selection">
                <h3 style="margin-bottom: 20px; font-size: 1.5rem; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-sliders-h"></i> Param√®tres
                </h3>
                
                <div style="margin-bottom: 25px;">
                    <div style="margin-bottom: 15px; font-weight: 600;">Nombre de questions</div>
                    <div class="question-grid">
                        <button class="question-btn" data-count="10">10</button>
                        <button class="question-btn" data-count="20">20</button>
                        <button class="question-btn" data-count="30">30</button>
                        <button class="question-btn" data-count="40">40</button>

          
                        <button class="question-btn" data-count="50">50</button>
                        <button class="question-btn" data-count="60">60</button>
                        <button class="question-btn" data-count="70">70</button>
                        <button class="question-btn" data-count="80">80</button>
                        <button class="question-btn" data-count="90">90</button>
                        <button class="question-btn" data-count="100">100</button>
                    </div>
                    <div style="text-align: center; margin-top: 20px; font-size: 1.2rem;">
                        S√©lectionn√© : <span id="selectedCount" style="color: var(--secondary); font-weight: 900;">10</span> questions
                    </div>
                </div>

                <div style="margin-top: 25px;">
                    <div style="margin-bottom: 15px; font-weight: 600;">Options audio</div>
                    <div style="display: flex; align-items: center; gap: 15px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 15px;">
                        <button id="voiceToggle" class="question-btn" style="flex: 1;">
                            <i class="fas fa-volume-up"></i> Audio ON
                        </button>
                        <button id="testVoice" class="question-btn" style="flex: 1;">
                            <i class="fas fa-play"></i> Tester
                        </button>
                    </div>
                </div>
            </div>

            <div class="players-list">
                <h3 style="margin-bottom: 20px; font-size: 1.5rem; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-users"></i> Joueurs (<span id="playerCountCreate">1</span>/10)
                </h3>
                <div id="playersListCreate">
                    <div class="player host">
                        <i class="fas fa-crown"></i>
                        <span>Vous (H√¥te)</span>
                    </div>
                </div>
            </div>

            <button id="startGameBtn" class="btn btn-primary" style="margin-top: 30px;">
                <i class="fas fa-rocket"></i> Lancer avec synchro
            </button>
        </div>

        <!-- √âCRAN REJOINDRE SALLE -->
        <div id="joinScreen" class="screen">
            <div style="margin-bottom: 30px;">
                <button class="btn btn-secondary" id="backFromJoin">
                    <i class="fas fa-arrow-left"></i> Retour
                </button>
                <h2 style="text-align: center; margin: 20px 0; font-size: 2rem; color: var(--secondary);">
                    <i class="fas fa-sign-in-alt"></i> Rejoindre
                </h2>
            </div>
            
            <div style="background: rgba(255, 255, 255, 0.15); padding: 30px; border-radius: 25px; margin: 30px 0; backdrop-filter: blur(10px);">
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-key" style="color: var(--secondary);"></i> Code de la salle
                    </label>
                    <input type="text" class="form-control" id="roomCodeInput" placeholder="Ex: ABC123" maxlength="6" style="text-transform: uppercase; text-align: center; font-size: 1.3rem; font-weight: 700; letter-spacing: 3px;">
                </div>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-user" style="color: var(--secondary);"></i> Ton pseudo
                    </label>
                    <input type="text" class="form-control" id="playerNameInput" placeholder="Entre ton nom de joueur" style="font-size: 1.2rem;">
                </div>
                
                <div style="margin-top: 25px;">
                    <div style="margin-bottom: 15px; font-weight: 600;">Options audio</div>
                    <div style="display: flex; align-items: center; gap: 15px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 15px;">
                        <button id="voiceToggleJoin" class="question-btn" style="flex: 1;">
                            <i class="fas fa-volume-up"></i> Audio ON
                        </button>
                        <button id="testVoiceJoin" class="question-btn" style="flex: 1;">
                            <i class="fas fa-play"></i> Tester
                        </button>
                    </div>
                </div>
                
                <button id="joinRoomConfirmBtn" class="btn btn-primary" style="margin-top: 30px;">
                    <i class="fas fa-bolt"></i> Rejoindre instantan√©ment
                </button>
                
                <div id="joinError" style="color: #ff6b6b; text-align: center; margin-top: 20px; padding: 15px; background: rgba(239, 68, 68, 0.1); border-radius: 15px; display: none;"></div>
            </div>
        </div>

        <!-- √âCRAN SALLE D'ATTENTE -->
        <div id="waitingScreen" class="screen">
            <div style="margin-bottom: 30px;">
                <button class="btn btn-secondary" id="backFromWaiting">
                    <i class="fas fa-arrow-left"></i> Quitter
                </button>
                <h2 style="text-align: center; margin: 20px 0; font-size: 2rem; color: var(--secondary);">
                    <i class="fas fa-clock"></i> Salle d'attente
                </h2>
            </div>
            
            <div class="room-code" style="margin: 20px 0;">
                <div class="code-label">CODE SALLE</div>
                <div class="code-value" id="waitingRoomCode">-----</div>
                <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">
                    <i class="fas fa-info-circle"></i> Partagez ce code avec vos amis
                </div>
            </div>

            <div class="players-list">
                <h3 style="margin-bottom: 20px; font-size: 1.5rem; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-users"></i> Joueurs connect√©s (<span id="playerCountWaiting">1</span>/10)
                </h3>
                <div id="waitingPlayersList">
                    <!-- Liste des joueurs -->
                </div>
            </div>

            <div id="waitingMessage" style="text-align: center; padding: 40px 20px;">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p style="font-size: 1.3rem; margin-top: 20px;">Synchronisation avec les autres joueurs...</p>
                    <p style="opacity: 0.8; margin-top: 10px;" id="syncStatus">Pr√™t ‚Ä¢ Latence: 0ms</p>
                </div>
            </div>

            <div id="hostControls" style="display: none;">
                <div style="text-align: center; margin-bottom: 30px; font-size: 1.2rem; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 20px;">
                    <div style="margin-bottom: 10px;">
                        <i class="fas fa-question-circle"></i>
                        Questions : <span id="selectedCountWaiting" style="color: var(--secondary); font-weight: 900;">10</span>
                    </div>
                    <div style="font-size: 1rem; opacity: 0.9;">
                        <i class="fas fa-sync-alt"></i> Synchronisation : <span id="syncReady" style="color: var(--success); font-weight: 700;">PR√äTE</span>
                    </div>
                </div>
                <button id="startGameWaitingBtn" class="btn btn-primary">
                    <i class="fas fa-play-circle"></i> Lancer partie synchronis√©e
                </button>
            </div>
        </div>

        <!-- √âCRAN DE JEU -->
        <div id="gameScreen" class="screen">
            <!-- En-t√™te du jeu -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; flex-wrap: wrap; gap: 15px;">
                <div style="background: rgba(255, 255, 255, 0.15); padding: 15px 25px; border-radius: 20px; min-width: 120px;">
                    <div style="font-size: 1rem; opacity: 0.9;">Question</div>
                    <div style="font-size: 1.8rem; font-weight: 900; color: var(--secondary);">
                        <span id="currentQuestion">1</span>/<span id="totalQuestions">10</span>
                    </div>
                </div>
                
                <div class="timer-container">
                    <svg class="timer-svg">
                        <circle class="timer-circle-bg" cx="60" cy="60" r="55"></circle>
                        <circle class="timer-circle" id="timerCircle" cx="60" cy="60" r="55"></circle>
                    </svg>
                    <div class="timer-text" id="timer">12</div>
                </div>
                
                <div style="background: rgba(255, 255, 255, 0.15); padding: 15px 25px; border-radius: 20px; min-width: 120px;">
                    <div style="font-size: 1rem; opacity: 0.9;">Score</div>
                    <div style="font-size: 1.8rem; font-weight: 900; color: var(--secondary);" id="playerScore">0</div>
                </div>
            </div>

            <!-- Carte question -->
            <div class="question-card">
                <div class="question-prefix">
                    <i class="fas fa-font"></i>
                    Champ lexical avec "<span id="lexicalPrefix" style="color: var(--secondary); font-size: 1.5rem;">Im</span>"
                </div>
                
                <div class="question-text" id="questionText">
                    Trouvez un mot qui commence par "Im"
                </div>
                
                <div class="question-hint" id="questionHint">
                    Indice : Cliquez sur le bouton audio pour entendre la question
                </div>
            </div>

            <!-- Contr√¥les audio -->
            <div style="display: flex; justify-content: center; gap: 15px; margin: 25px 0;">
                <button id="repeatQuestion" class="btn btn-secondary" style="width: auto; padding: 15px 30px;">
                    <i class="fas fa-redo"></i> R√©√©couter
                </button>
                <button id="voiceControl" class="btn btn-primary" style="width: auto; padding: 15px 30px;">
                    <i class="fas fa-volume-up"></i> Audio ON
                </button>
            </div>

            <!-- Zone de r√©ponse -->
            <div class="answer-input-container">
                <input type="text" class="answer-input" id="answerInput" 
                       placeholder="√âcris ta r√©ponse ici..." 
                       autocomplete="off"
                       style="font-size: 1.3rem; text-align: center;">
                <button id="submitAnswerBtn" class="btn btn-primary" style="width: auto; min-width: 100px; padding: 0 30px;">
                    <i class="fas fa-paper-plane"></i> Valider
                </button>
            </div>

            <!-- Boutons rapides -->
            <div class="quick-buttons">
                <button class="quick-btn" onclick="insertPrefix('Im')">Im</button>
                <button class="quick-btn" onclick="insertPrefix('Di')">Di</button>
                <button class="quick-btn" onclick="insertPrefix('Em')">Em</button>
                <button class="quick-btn" onclick="insertPrefix('Pe')">Pe</button>
                <button class="quick-btn" onclick="insertPrefix('No')">No</button>
                <button class="quick-btn" onclick="insertPrefix('La')">La</button>
                <button class="quick-btn" onclick="insertPrefix('Ch')">Ch</button>
                <button class="quick-btn" onclick="insertPrefix('Re')">Re</button>
            </div>

            <!-- Classement en direct -->
            <div class="scoreboard">
                <h3 style="margin-bottom: 20px; font-size: 1.5rem; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-chart-line"></i> Classement en direct
                    <span style="font-size: 0.9rem; opacity: 0.8; margin-left: auto;" id="syncInfo">Sync: 0ms</span>
                </h3>
                <div id="scoreboard">
                    <!-- Classement dynamique -->
                </div>
            </div>
        </div>

        <!-- √âCRAN R√âSULTATS -->
        <div id="resultsScreen" class="screen">
            <div style="text-align: center; margin-bottom: 40px;">
                <h1 style="font-size: 3rem; color: var(--secondary); margin-bottom: 20px; animation: bounce 2s infinite;">
                    <i class="fas fa-trophy"></i>
                </h1>
                <h2 style="font-size: 2.5rem; margin-bottom: 10px; font-weight: 900;">FIN DE LA PARTIE !</h2>
                <p style="font-size: 1.2rem; opacity: 0.9;">
                    <span id="totalQuestionsPlayed">10</span> questions ‚Ä¢ 
                    <span id="totalPlayers">2</span> joueurs ‚Ä¢
                    <span id="gameDuration">0s</span>
                </p>
            </div>

            <!-- Gagnant -->
            <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(239, 68, 68, 0.2)); padding: 40px; border-radius: 25px; text-align: center; margin: 30px 0; border: 2px solid rgba(245, 158, 11, 0.3); position: relative; overflow: hidden;">
                <div style="position: absolute; top: 10px; right: 10px; background: var(--secondary); color: white; padding: 5px 15px; border-radius: 20px; font-weight: 700; font-size: 0.9rem;">
                    üèÜ GAGNANT üèÜ
                </div>
                <div style="font-size: 2.5rem; font-weight: 900; color: var(--secondary); margin-bottom: 10px; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);" id="winnerName">-</div>
                <div style="font-size: 2rem; font-weight: 700; margin-bottom: 10px;" id="winnerScore">0 points</div>
                <div style="font-size: 1.1rem; opacity: 0.9;" id="winnerStats">-</div>
            </div>

            <!-- Classement final -->
            <div class="scoreboard">
                <h3 style="margin-bottom: 20px; font-size: 1.5rem; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-medal"></i> Classement final
                </h3>
                <div id="finalScoreboard">
                    <!-- Classement final -->
                </div>
            </div>

            <!-- Actions -->
            <div style="margin-top: 40px;">
                <button id="playAgainBtn" class="btn btn-primary" style="margin-bottom: 15px;">
                    <i class="fas fa-redo"></i> Rejouer avec m√™mes joueurs
                </button>
                <button id="newRoomBtn" class="btn btn-secondary" style="margin-bottom: 15px;">
                    <i class="fas fa-plus-circle"></i> Nouvelle salle
                </button>
                <button id="backToHomeBtn" class="btn" style="background: rgba(255, 255, 255, 0.1); color: white; width: 100%;">
                    <i class="fas fa-home"></i> Retour √† l'accueil
                </button>
            </div>
        </div>
    </div>

    <!-- NOTIFICATION FLOATING -->
    <div id="floatingNotification" style="display: none;"></div>

    <script>
        // ==================== SYST√àME DE SYNCHRONISATION PARFAITE ====================
        class PerfectSyncSystem {
            constructor() {
                this.serverTimeOffset = 0;
                this.pingHistory = [];
                this.maxPingSamples = 10;
                this.syncInterval = null;
                this.lastSync = 0;
                this.syncPrecision = 50; // ms de pr√©cision
            }

            // Synchroniser avec le serveur (simul√© ici)
            async syncWithServer() {
                const start = Date.now();
                
                // Simulation de latence r√©seau
                const latency = Math.random() * 100 + 20; // 20-120ms
                await new Promise(resolve => setTimeout(resolve, latency));
                
                const end = Date.now();
                const roundTrip = end - start;
                const estimatedServerTime = start + (roundTrip / 2);
                
                // Calculer l'offset
                const serverTime = estimatedServerTime;
                const clientTime = Date.now();
                const offset = serverTime - clientTime;
                
                // Ajouter √† l'historique
                this.pingHistory.push({
                    offset,
                    latency: roundTrip / 2,
                    timestamp: clientTime
                });
                
                // Garder seulement les derniers √©chantillons
                if (this.pingHistory.length > this.maxPingSamples) {
                    this.pingHistory.shift();
                }
                
                // Calculer l'offset m√©dian pour plus de stabilit√©
                const offsets = this.pingHistory.map(p => p.offset).sort((a, b) => a - b);
                const medianOffset = offsets[Math.floor(offsets.length / 2)];
                
                this.serverTimeOffset = medianOffset;
                this.lastSync = clientTime;
                
                return {
                    offset: medianOffset,
                    latency: roundTrip / 2,
                    precision: this.calculatePrecision()
                };
            }

            calculatePrecision() {
                if (this.pingHistory.length < 2) return 999;
                const latencies = this.pingHistory.map(p => p.latency);
                const avgLatency = latencies.reduce((a, b) => a + b) / latencies.length;
                const variance = latencies.reduce((a, b) => a + Math.pow(b - avgLatency, 2), 0) / latencies.length;
                return Math.sqrt(variance);
            }

            getSyncedTime() {
                return Date.now() + this.serverTimeOffset;
            }

            // Convertir un timestamp serveur en timestamp client
            serverToClientTime(serverTime) {
                return serverTime - this.serverTimeOffset;
            }

            // V√©rifier si la synchronisation est bonne
            isWellSynced() {
                if (this.pingHistory.length < 3) return false;
                const precision = this.calculatePrecision();
                return precision < this.syncPrecision;
            }

            startContinuousSync() {
                if (this.syncInterval) clearInterval(this.syncInterval);
                
                this.syncInterval = setInterval(async () => {
                    try {
                        const syncResult = await this.syncWithServer();
                        updateSyncStatus(syncResult);
                    } catch (error) {
                        console.warn('Sync error:', error);
                    }
                }, 5000); // Sync toutes les 5 secondes
            }

            stopSync() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
            }
        }

        // ==================== SYST√àME AUDIO AVANC√â ====================
        class AdvancedAudioSystem {
            constructor() {
                this.speechSynthesis = window.speechSynthesis;
                this.voices = [];
                this.currentVoice = null;
                this.isSpeaking = false;
                this.volume = 1;
                this.rate = 1;
                this.pitch = 1;
                this.audioContext = null;
                this.oscillator = null;
                this.gainNode = null;
                
                this.init();
            }

            async init() {
                // Charger les voix disponibles
                await this.loadVoices();
                
                // Initialiser l'audio context pour les bips
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('AudioContext non support√©:', e);
                }
            }

            loadVoices() {
                return new Promise((resolve) => {
                    if (this.speechSynthesis.getVoices().length > 0) {
                        this.voices = this.speechSynthesis.getVoices();
                        this.selectFrenchVoice();
                        resolve();
                    } else {
                        this.speechSynthesis.onvoiceschanged = () => {
                            this.voices = this.speechSynthesis.getVoices();
                            this.selectFrenchVoice();
                            resolve();
                        };
                    }
                });
            }

            selectFrenchVoice() {
                // Chercher une voix fran√ßaise
                const frenchVoices = this.voices.filter(voice => 
                    voice.lang.includes('fr') || 
                    voice.name.includes('French') ||
                    voice.name.includes('fran√ßais')
                );
                
                if (frenchVoices.length > 0) {
                    this.currentVoice = frenchVoices[0];
                } else if (this.voices.length > 0) {
                    this.currentVoice = this.voices[0];
                }
            }

            speak(text, options = {}) {
                return new Promise((resolve) => {
                    if (!this.speechSynthesis || !this.currentVoice) {
                        console.warn('Speech synthesis non disponible');
                        resolve();
                        return;
                    }

                    // Arr√™ter la parole en cours
                    this.stopSpeaking();

                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Configuration
                    utterance.voice = this.currentVoice;
                    utterance.volume = options.volume || this.volume;
                    utterance.rate = options.rate || this.rate;
                    utterance.pitch = options.pitch || this.pitch;
                    utterance.lang = 'fr-FR';

                    // √âv√©nements
                    utterance.onstart = () => {
                        this.isSpeaking = true;
                        showVoiceIndicator(true);
                    };

                    utterance.onend = () => {
                        this.isSpeaking = false;
                        showVoiceIndicator(false);
                        resolve();
                    };

                    utterance.onerror = (event) => {
                        console.warn('Speech error:', event);
                        this.isSpeaking = false;
                        showVoiceIndicator(false);
                        resolve();
                    };

                    // Parler
                    this.speechSynthesis.speak(utterance);
                });
            }

            stopSpeaking() {
                if (this.speechSynthesis && this.isSpeaking) {
                    this.speechSynthesis.cancel();
                    this.isSpeaking = false;
                    showVoiceIndicator(false);
                }
            }

            playBeep(type = 'start') {
                if (!this.audioContext) return;

                try {
                    if (this.oscillator) {
                        this.oscillator.stop();
                        this.oscillator.disconnect();
                    }

                    this.oscillator = this.audioContext.createOscillator();
                    this.gainNode = this.audioContext.createGain();

                    // Configuration selon le type
                    switch(type) {
                        case 'start':
                            this.oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                            break;
                        case 'correct':
                            this.oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                            break;
                        case 'wrong':
                            this.oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                            break;
                        case 'time':
                            this.oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                            break;
                    }

                    this.gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    this.gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

                    this.oscillator.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);

                    this.oscillator.start();
                    this.oscillator.stop(this.audioContext.currentTime + 0.5);

                } catch (e) {
                    console.warn('Beep error:', e);
                }
            }

            testAudio() {
                this.playBeep('start');
                setTimeout(() => {
                    this.speak('Test audio r√©ussi. La synth√®se vocale fonctionne correctement.');
                }, 500);
            }

            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
            }

            setRate(rate) {
                this.rate = Math.max(0.5, Math.min(2, rate));
            }
        }

        // ==================== GESTION TEMPS R√âEL ====================
        class RealTimeManager {
            constructor() {
                this.roomCode = null;
                this.players = new Map();
                this.gameState = 'waiting';
                this.questionStartTime = 0;
                this.questionDuration = 12000; // 12 secondes
                this.syncTolerance = 200; // 200ms de tol√©rance
                this.lastBroadcast = 0;
                this.broadcastInterval = 100; // Broadcast toutes les 100ms
                this.broadcastTimer = null;
            }

            // Simulation d'un serveur WebSocket
            simulateServerConnection() {
                // En r√©alit√©, ce serait un WebSocket ou Firebase
                console.log('Connexion serveur simul√©e');
                
                // Simuler la r√©ception de messages
                setInterval(() => {
                    this.receiveBroadcast();
                }, Math.random() * 50 + 50); // 50-100ms de latence simul√©e
            }

            broadcastState() {
                const now = syncSystem.getSyncedTime();
                if (now - this.lastBroadcast < this.broadcastInterval) return;

                const state = {
                    type: 'game_state',
                    roomCode: this.roomCode,
                    timestamp: now,
                    gameState: this.gameState,
                    currentQuestion: gameState.currentQuestion,
                    questionStartTime: this.questionStartTime,
                    timeRemaining: this.getTimeRemaining(),
                    players: Array.from(this.players.values())
                };

                // Envoyer l'√©tat √† tous les joueurs
                this.sendToAll(state);
                this.lastBroadcast = now;
            }

            sendToAll(data) {
                // Simuler l'envoi r√©seau
                setTimeout(() => {
                    window.dispatchEvent(new CustomEvent('server_message', { detail: data }));
                }, Math.random() * 30 + 10); // 10-40ms de latence
            }

            receiveBroadcast() {
                // Simuler la r√©ception de messages d'autres joueurs
                const fakeMessage = {
                    type: 'player_action',
                    playerId: 'player_' + Math.floor(Math.random() * 1000),
                    action: 'answer',
                    answer: 'Test',
                    timestamp: Date.now(),
                    correct: Math.random() > 0.5
                };

                if (Math.random() > 0.7) { // 30% chance de recevoir un message
                    window.dispatchEvent(new CustomEvent('server_message', { detail: fakeMessage }));
                }
            }

            startQuestion(questionNumber) {
                const startTime = syncSystem.getSyncedTime();
                this.questionStartTime = startTime;
                this.gameState = 'playing';
                
                // Synchroniser le d√©marrage pour tous
                const syncData = {
                    type: 'question_start',
                    questionNumber,
                    startTime,
                    duration: this.questionDuration
                };
                
                this.sendToAll(syncData);
                this.startBroadcasting();
                
                return startTime;
            }

            getTimeRemaining() {
                if (!this.questionStartTime) return 0;
                
                const now = syncSystem.getSyncedTime();
                const elapsed = now - this.questionStartTime;
                const remaining = this.questionDuration - elapsed;
                
                return Math.max(0, remaining);
            }

            startBroadcasting() {
                if (this.broadcastTimer) clearInterval(this.broadcastTimer);
                
                this.broadcastTimer = setInterval(() => {
                    this.broadcastState();
                }, this.broadcastInterval);
            }

            stopBroadcasting() {
                if (this.broadcastTimer) {
                    clearInterval(this.broadcastTimer);
                    this.broadcastTimer = null;
                }
            }

            // V√©rifier la synchronisation des joueurs
            checkPlayerSync(playerTimes) {
                const serverTime = syncSystem.getSyncedTime();
                const offsets = playerTimes.map(time => Math.abs(serverTime - time));
                const maxOffset = Math.max(...offsets);
                
                return {
                    synced: maxOffset < this.syncTolerance,
                    maxOffset,
                    averageOffset: offsets.reduce((a, b) => a + b) / offsets.length
                };
            }
        }

        // ==================== INITIALISATION SYST√àMES ====================
        const syncSystem = new PerfectSyncSystem();
        const audioSystem = new AdvancedAudioSystem();
        const realTimeManager = new RealTimeManager();

        // ==================== √âTAT GLOBAL DU JEU ====================
        let gameState = {
            playerId: 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            playerName: '',
            roomCode: null,
            isHost: false,
            selectedQuestions: 10,
            currentQuestion: 1,
            score: 0,
            connected: true,
            voiceEnabled: true,
            questions: [],
            players: {},
            timerInterval: null,
            timeLeft: 12,
            questionStartTime: 0,
            lastAnswerTime: 0,
            syncStatus: 'syncing',
            gameStarted: false,
            answers: []
        };

        // ==================== BASE DE DONN√âES DES QUESTIONS ====================
        const QUESTIONS_DB = {
            "Im": [
                {word: "Imb√©cile", hint: "personne stupide ou idiote"},
                {word: "Immacul√©", hint: "parfaitement propre ou pur"},
                {word: "Immat√©riel", hint: "qui n'a pas de corps physique"},
                {word: "Imminent", hint: "qui va se produire tr√®s bient√¥t"},
                {word: "Immobile", hint: "qui ne bouge pas"},
                {word: "Immortel", hint: "qui ne meurt pas ou qui vit √©ternellement"},
                {word: "Immuable", hint: "qui ne change pas"},
                {word: "Immuabilit√©", hint: "√©tat de ce qui ne change pas"},
                {word: "Immunit√©", hint: "protection contre une maladie ou une infection"},
                {word: "Impartial", hint: "qui ne prend pas parti"},
                {word: "Impassible", hint: "qui ne montre pas d'√©motion"},
                {word: "Imp√©ratif", hint: "qui est n√©cessaire ou obligatoire"},
                {word: "Imperturbable", hint: "qui ne se laisse pas perturber"},
                {word: "Impie", hint: "qui manque de respect envers la religion"},
                {word: "Implacable", hint: "qui ne peut pas √™tre apais√© ou arr√™t√©"},
                {word: "Impossible", hint: "qui ne peut pas √™tre r√©alis√© ou accompli"},
                {word: "Improbable", hint: "peu probable, qui a peu de chances de se produire"},
                {word: "Improviste", hint: "sans pr√©paration, de mani√®re impromptue"},
                {word: "Improviser", hint: "cr√©er ou faire quelque chose spontan√©ment"},
                {word: "Imaginer", hint: "cr√©er des images mentales ou des id√©es dans son esprit"},
                {word: "Impressionnant", hint: "qui produit une forte impression"},
                {word: "Impacter", hint: "avoir un effet ou une influence sur quelque chose"},
                {word: "Impair", hint: "qui est impair, qui ne peut pas √™tre divis√© par deux"},
                {word: "Imagination", hint: "capacit√© √† cr√©er des images, des id√©es"},
                {word: "Imiter", hint: "copier ou reproduire le comportement de quelqu'un"},
                {word: "Imitation", hint: "action de copier ou de reproduire quelque chose"},
                {word: "Imbattable", hint: "qui ne peut pas √™tre vaincu, qui est invaincu"},
                {word: "Imbelliqueux", hint: "qui cherche la discorde ou le conflit"},
                {word: "Immigration", hint: "action de s'installer dans un pays √©tranger"}
            ],
            "Di": [
                {word: "Direction", hint: "position ou trajectoire vers laquelle on se d√©place"},
                {word: "Difficult√©", hint: "obstacle ou d√©fi qui rend quelque chose difficile"},
                {word: "Discipline", hint: "ob√©issance √† des r√®gles pour atteindre un objectif"},
                {word: "Dialogue", hint: "conversation entre deux personnes ou plus"},
                {word: "Diversit√©", hint: "vari√©t√© ou diff√©rence dans un groupe"},
                {word: "Diplomatie", hint: "art de n√©gocier et r√©soudre les conflits"},
                {word: "Dictionnaire", hint: "livre qui r√©pertorie les mots et d√©finitions"},
                {word: "Disparition", hint: "fait de ne plus √™tre pr√©sent ou visible"},
                {word: "Dimension", hint: "mesure de la taille ou de l'√©tendue"},
                {word: "Directionnel", hint: "qui se rapporte √† la direction"}
            ],
            "Em": [
                {word: "Emotion", hint: "r√©action affective intense"},
                {word: "Empathie", hint: "capacit√© de comprendre les sentiments des autres"},
                {word: "Emploi", hint: "travail ou occupation r√©mun√©r√©"},
                {word: "Empreinte", hint: "marque laiss√©e par un objet ou une personne"},
                {word: "Emotionnel", hint: "qui est li√© aux √©motions"},
                {word: "Empire", hint: "vaste territoire gouvern√© par un souverain"},
                {word: "Embl√®me", hint: "symbole qui repr√©sente une id√©e ou organisation"},
                {word: "Empoisonnement", hint: "√©tat d'avoir √©t√© intoxiqu√©"},
                {word: "Ermite", hint: "personne qui vit seule, retir√©e du monde"},
                {word: "Emphase", hint: "insistance particuli√®re mise sur quelque chose"}
            ]
        };

        // ==================== INITIALISATION ====================
        document.addEventListener('DOMContentLoaded', function() {
            initParticles();
            initEventListeners();
            initSystems();
            loadPlayerName();
            startSyncSystem();
            updateStats();
        });

        function initParticles() {
            const particlesContainer = document.getElementById('particles');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = Math.random() * 15 + 5 + 'px';
                particle.style.height = particle.style.width


                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + 'vh';
                particle.style.animationDelay = Math.random() * 5 + 's';
                particle.style.animationDuration = Math.random() * 30 + 15 + 's';
                particlesContainer.appendChild(particle);
            }
        }

        function initEventListeners() {
            // Navigation
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('joinRoomBtn').addEventListener('click', showJoinScreen);
            document.getElementById('backFromCreate').addEventListener('click', () => showScreen('homeScreen'));
            document.getElementById('backFromJoin').addEventListener('click', () => showScreen('homeScreen'));
            document.getElementById('backFromWaiting').addEventListener('click', leaveRoom);
            document.getElementById('backToHomeBtn').addEventListener('click', () => showScreen('homeScreen'));
            document.getElementById('newRoomBtn').addEventListener('click', () => showScreen('homeScreen'));
            
            // Cr√©ation salle
            document.getElementById('copyCodeBtn').addEventListener('click', copyRoomCode);
            document.querySelectorAll('.question-btn[data-count]').forEach(btn => {
                btn.addEventListener('click', () => selectQuestionCount(parseInt(btn.dataset.count)));
            });
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('startGameWaitingBtn').addEventListener('click', startGame);
            
            // Audio
            document.getElementById('voiceToggle').addEventListener('click', toggleVoice);
            document.getElementById('voiceToggleJoin').addEventListener('click', toggleVoiceJoin);
            document.getElementById('testVoice').addEventListener('click', () => audioSystem.testAudio());
            document.getElementById('testVoiceJoin').addEventListener('click', () => audioSystem.testAudio());
            document.getElementById('repeatQuestion').addEventListener('click', repeatQuestion);
            document.getElementById('voiceControl').addEventListener('click', toggleVoiceControl);
            
            // Rejoindre salle
            document.getElementById('joinRoomConfirmBtn').addEventListener('click', joinRoom);
            document.getElementById('roomCodeInput').addEventListener('keypress', e => e.key === 'Enter' && joinRoom());
            document.getElementById('playerNameInput').addEventListener('keypress', e => e.key === 'Enter' && joinRoom());
            
            // Jeu
            document.getElementById('submitAnswerBtn').addEventListener('click', submitAnswer);
            document.getElementById('answerInput').addEventListener('keypress', e => e.key === 'Enter' && submitAnswer());
            document.getElementById('playAgainBtn').addEventListener('click', playAgain);
            
            // Initialiser la s√©lection de questions
            selectQuestionCount(10);
            
            // √âcouter les messages du serveur simul√©
            window.addEventListener('server_message', handleServerMessage);
            
            // Gestion de la visibilit√©
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        function initSystems() {
            // D√©marrer le syst√®me de synchronisation
            syncSystem.startContinuousSync();
            
            // Simuler la connexion serveur
            realTimeManager.simulateServerConnection();
            
            // V√©rifier la compatibilit√© audio
            checkAudioCompatibility();
        }

        function loadPlayerName() {
            const savedName = localStorage.getItem('quizPlayerName');
            if (savedName) {
                gameState.playerName = savedName;
                document.getElementById('playerNameInput').value = savedName;
            } else {
                gameState.playerName = 'Joueur_' + Math.floor(Math.random() * 1000);
                document.getElementById('playerNameInput').value = gameState.playerName;
            }
        }

        function savePlayerName(name) {
            gameState.playerName = name;
            localStorage.setItem('quizPlayerName', name);
        }

        // ==================== SYST√àME DE SYNCHRO ====================
        function startSyncSystem() {
            syncSystem.startContinuousSync();
            
            // Mettre √† jour l'interface avec le statut de sync
            setInterval(() => {
                updateSyncDisplay();
            }, 1000);
        }

        function updateSyncStatus(syncResult) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (syncResult.latency < 100) {
                statusDot.className = 'status-dot';
                statusText.textContent = `Sync: ${Math.round(syncResult.latency)}ms`;
                statusText.style.color = '#10b981';
            } else if (syncResult.latency < 300) {
                statusDot.className = 'status-dot syncing';
                statusText.textContent = `Sync: ${Math.round(syncResult.latency)}ms`;
                statusText.style.color = '#f59e0b';
            } else {
                statusDot.className = 'status-dot offline';
                statusText.textContent = `Sync: ${Math.round(syncResult.latency)}ms`;
                statusText.style.color = '#ef4444';
            }
            
            // Mettre √† jour l'info de sync dans le jeu
            if (document.getElementById('syncInfo')) {
                document.getElementById('syncInfo').textContent = `Sync: ${Math.round(syncResult.latency)}ms`;
            }
            
            // Mettre √† jour le statut de sync dans la salle d'attente
            if (document.getElementById('syncStatus')) {
                const precision = syncSystem.calculatePrecision();
                document.getElementById('syncStatus').textContent = 
                    `Pr√™t ‚Ä¢ Latence: ${Math.round(syncResult.latency)}ms ‚Ä¢ Pr√©cision: ${Math.round(precision)}ms`;
            }
        }

        function updateSyncDisplay() {
            const isSynced = syncSystem.isWellSynced();
            const syncIndicator = document.getElementById('syncIndicator');
            
            if (isSynced) {
                syncIndicator.style.display = 'none';
                if (gameState.isHost && document.getElementById('syncReady')) {
                    document.getElementById('syncReady').textContent = 'PR√äTE';
                    document.getElementById('syncReady').style.color = '#10b981';
                }
            } else {
                syncIndicator.style.display = 'flex';
                if (gameState.isHost && document.getElementById('syncReady')) {
                    document.getElementById('syncReady').textContent = 'SYNC...';
                    document.getElementById('syncReady').style.color = '#f59e0b';
                }
            }
        }

        // ==================== SYST√àME AUDIO ====================
        function checkAudioCompatibility() {
            if (!('speechSynthesis' in window)) {
                showNotification('Attention: Synth√®se vocale non support√©e', 'warning');
                gameState.voiceEnabled = false;
                updateVoiceButtons(false);
            }
        }

        function toggleVoice() {
            gameState.voiceEnabled = !gameState.voiceEnabled;
            updateVoiceButtons(gameState.voiceEnabled);
            showNotification(
                gameState.voiceEnabled ? 'Audio activ√©' : 'Audio d√©sactiv√©',
                gameState.voiceEnabled ? 'success' : 'info'
            );
        }

        function toggleVoiceJoin() {
            toggleVoice();
        }

        function toggleVoiceControl() {
            gameState.voiceEnabled = !gameState.voiceEnabled;
            const btn = document.getElementById('voiceControl');
            const icon = btn.querySelector('i');
            
            if (gameState.voiceEnabled) {
                btn.innerHTML = '<i class="fas fa-volume-up"></i> Audio ON';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                audioSystem.playBeep('start');
            } else {
                btn.innerHTML = '<i class="fas fa-volume-mute"></i> Audio OFF';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
        }

        function updateVoiceButtons(enabled) {
            const btns = ['voiceToggle', 'voiceToggleJoin'];
            btns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.innerHTML = enabled ? 
                        '<i class="fas fa-volume-up"></i> Audio ON' : 
                        '<i class="fas fa-volume-mute"></i> Audio OFF';
                }
            });
        }

        function showVoiceIndicator(showing) {
            const indicator = document.getElementById('voiceIndicator');
            if (showing) {
                indicator.style.display = 'flex';
            } else {
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 500);
            }
        }

        function repeatQuestion() {
            if (gameState.questions.length > 0) {
                const currentQuestion = gameState.questions[gameState.currentQuestion - 1];
                announceQuestion(currentQuestion);
            }
        }

        function announceQuestion(question) {
            if (!gameState.voiceEnabled) return;
            
            const text = `Champ lexical avec ${question.prefix}. Trouvez un mot qui commence par ${question.prefix}. ${question.hint}`;
            audioSystem.speak(text, { rate: 0.9 });
        }

        // ==================== GESTION DES √âCRANS ====================
        function showScreen(screenId) {
            // Animation de transition
            document.querySelectorAll('.screen').forEach(screen => {
                if (screen.classList.contains('active')) {
                    screen.classList.add('fade-out');
                    setTimeout(() => {
                        screen.classList.remove('active');
                        screen.classList.remove('fade-out');
                    }, 300);
                }
            });
            
            // Afficher le nouvel √©cran
            setTimeout(() => {
                const screen = document.getElementById(screenId);
                screen.classList.add('active');
                
                // Mettre √† jour les stats si on retourne √† l'accueil
                if (screenId === 'homeScreen') {
                    updateStats();
                }
            }, 300);
        }

        // ==================== CR√âATION DE SALLE ====================
        function createRoom() {
            // Sauvegarder le nom
            const playerName = document.getElementById('playerNameInput').value.trim() || gameState.playerName;
            savePlayerName(playerName);
            
            // G√©n√©rer un code de salle
            const roomCode = generateRoomCode();
            gameState.roomCode = roomCode;
            gameState.isHost = true;
            gameState.score = 0;
            gameState.currentQuestion = 1;
            gameState.gameStarted = false;
            
            // Mettre √† jour l'interface
            document.getElementById('roomCode').textContent = roomCode;
            document.getElementById('waitingRoomCode').textContent = roomCode;
            
            // Ajouter l'h√¥te √† la liste
            updatePlayerList([
                {id: gameState.playerId, name: playerName, score: 0, isHost: true, answered: false}
            ], 'playersListCreate');
            
            updatePlayerList([
                {id: gameState.playerId, name: playerName, score: 0, isHost: true, answered: false}
            ], 'waitingPlayersList');
            
            // Configurer la salle dans le manager temps r√©el
            realTimeManager.roomCode = roomCode;
            realTimeManager.players.set(gameState.playerId, {
                id: gameState.playerId,
                name: playerName,
                score: 0,
                isHost: true,
                connected: true,
                lastPing: Date.now()
            });
            
            // Afficher l'√©cran
            showScreen('createScreen');
            
            showNotification('Salle cr√©√©e avec succ√®s', 'success');
            audioSystem.playBeep('start');
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function copyRoomCode() {
            const code = document.getElementById('roomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Code copi√© dans le presse-papier', 'success');
            });
        }

        // ==================== S√âLECTION DES QUESTIONS ====================
        function selectQuestionCount(count) {
            gameState.selectedQuestions = count;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('selectedCountWaiting').textContent = count;
            
            // Mettre √† jour les boutons
            document.querySelectorAll('.question-btn[data-count]').forEach(btn => {
                btn.classList.toggle('selected', parseInt(btn.dataset.count) === count);
            });
        }

        // ==================== REJOINDRE UNE SALLE ====================
        function showJoinScreen() {
            showScreen('joinScreen');
            document.getElementById('roomCodeInput').focus();
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            const playerName = document.getElementById('playerNameInput').value.trim();
            
            // Validation
            if (!roomCode || roomCode.length !== 6) {
                showError('Code invalide (6 caract√®res requis)');
                return;
            }
            
            if (!playerName) {
                showError('Entrez un pseudo');
                return;
            }
            
            savePlayerName(playerName);
            gameState.roomCode = roomCode;
            gameState.isHost = false;
            gameState.score = 0;
            
            // Simuler la v√©rification de salle
            showLoading('Connexion √† la salle...');
            
            setTimeout(() => {
                if (roomCode.length === 6) { // Toujours valider pour la d√©mo
                    showWaitingScreen();
                } else {
                    showError('Salle introuvable');
                }
            }, 1000);
        }

        function showLoading(message) {
            // Pourrait √™tre impl√©ment√© comme un overlay de chargement
            console.log(message);
        }

        function showWaitingScreen() {
            document.getElementById('waitingRoomCode').textContent = gameState.roomCode;
            
            // Simuler d'autres joueurs
            const players = [
                {id: 'host', name: 'H√¥te', score: 0, isHost: true, answered: false},
                {id: gameState.playerId, name: gameState.playerName, score: 0, isHost: false, answered: false},
                {id: 'player2', name: 'Alex', score: 0, isHost: false, answered: false},
                {id: 'player3', name: 'Sam', score: 0, isHost: false, answered: false}
            ];
            
            updatePlayerList(players, 'waitingPlayersList');
            document.getElementById('playerCountWaiting').textContent = players.length;
            
            // Cacher les contr√¥les h√¥te
            document.getElementById('hostControls').style.display = 'none';
            document.getElementById('waitingMessage').style.display = 'block';
            
            showScreen('waitingScreen');
            
            // Simuler des mises √† jour de joueurs
            simulatePlayerUpdates();
            
            showNotification('Connect√© √† la salle', 'success');
            audioSystem.playBeep('start');
        }

        function simulatePlayerUpdates() {
            setInterval(() => {
                if (document.getElementById('waitingScreen').classList.contains('active')) {
                    // Simuler l'arriv√©e de nouveaux joueurs
                    const playerCount = Math.floor(Math.random() * 3) + 3; // 3-5 joueurs
                    document.getElementById('playerCountWaiting').textContent = playerCount;
                }
            }, 3000);
        }

        // ==================== D√âMARRER LA PARTIE ====================
        function startGame() {
            if (!syncSystem.isWellSynced()) {
                showNotification('Synchronisation en cours, veuillez patienter...', 'warning');
                return;
            }
            
            // G√©n√©rer les questions
            const questions = generateQuestions(gameState.selectedQuestions);
            gameState.questions = questions;
            gameState.gameStarted = true;
            
            // Initialiser l'interface
            document.getElementById('totalQuestions').textContent = gameState.selectedQuestions;
            document.getElementById('playerScore').textContent = '0';
            
            // Simuler des joueurs
            const players = [
                {id: 'host', name: 'H√¥te', score: 0, isHost: true},
                {id: gameState.playerId, name: gameState.playerName, score: 0, isHost: false},
                {id: 'player2', name: 'Alex', score: Math.floor(Math.random() * 30), isHost: false},
                {id: 'player3', name: 'Sam', score: Math.floor(Math.random() * 20), isHost: false}
            ];
            
            updateScoreboard(players);
            
            // D√©marrer la premi√®re question avec synchronisation
            const startTime = realTimeManager.startQuestion(1);
            gameState.questionStartTime = startTime;
            
            // Charger la question
            setTimeout(() => {
                loadQuestion(1, startTime);
            }, 1000); // D√©lai pour laisser le temps √† tous de se pr√©parer
            
            showScreen('gameScreen');
            
            // Jouer le son de d√©but
            audioSystem.playBeep('start');
            showNotification('Partie d√©marr√©e ! Synchronisation activ√©e', 'success');
        }

        // ==================== G√âN√âRATION DES QUESTIONS ====================
        function generateQuestions(count) {
            const questions = [];
            const prefixes = Object.keys(QUESTIONS_DB);
            
            // M√©langer les pr√©fixes
            const shuffledPrefixes = [...prefixes].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < count; i++) {
                const prefix = shuffledPrefixes[i % shuffledPrefixes.length];
                const prefixQuestions = QUESTIONS_DB[prefix];
                
                if (prefixQuestions && prefixQuestions.length > 0) {
                    const randomQuestion = prefixQuestions[Math.floor(Math.random() * prefixQuestions.length)];
                    
                    questions.push({
                        number: i + 1,
                        prefix: prefix,
                        word: randomQuestion.word,
                        hint: randomQuestion.hint,
                        answered: false
                    });
                }
            }
            
            return questions;
        }

        // ==================== GESTION DES QUESTIONS ====================
        function loadQuestion(questionNumber, startTime) {
            const question = gameState.questions[questionNumber - 1];
            if (!question) return;
            
            gameState.currentQuestion = questionNumber;
            gameState.timeLeft = 12;
            gameState.questionStartTime = startTime || syncSystem.getSyncedTime();
            gameState.lastAnswerTime = 0;
            
            // Mettre √† jour l'interface
            document.getElementById('currentQuestion').textContent = questionNumber;
            document.getElementById('lexicalPrefix').textContent = question.prefix;
            document.getElementById('questionText').textContent = `Trouvez un mot qui commence par "${question.prefix}"`;
            document.getElementById('questionHint').textContent = question.hint;
            document.getElementById('answerInput').value = '';
            document.getElementById('answerInput').className = 'answer-input';
            document.getElementById('timer').textContent = '12';
            document.getElementById('timer').className = 'timer-text';
            
            // R√©initialiser le timer visuel
            const timerCircle = document.getElementById('timerCircle');
            timerCircle.style.strokeDashoffset = '377';
            timerCircle.style.transition = 'stroke-dashoffset 12s linear';
            timerCircle.className = 'timer-circle';
            
            // Lancer le timer synchronis√©
            startSyncedTimer(startTime);
            
            // Annoncer la question
            if (gameState.voiceEnabled) {
                setTimeout(() => {
                    announceQuestion(question);
                }, 500);
            }
            
            // D√©marrer l'animation de la barre de progression
            document.querySelector('.question-card:before').style.animation = 'none';
            setTimeout(() => {
                document.querySelector('.question-card:before').style.animation = 'progressBar 12s linear forwards';
            }, 10);
        }

        function startSyncedTimer(startTime) {
            clearInterval(gameState.timerInterval);
            
            const updateTimer = () => {
                const now = syncSystem.getSyncedTime();
                const elapsed = now - gameState.questionStartTime;
                const remaining = Math.max(0, 12000 - elapsed);
                
                gameState.timeLeft = Math.ceil(remaining / 1000);
                
                // Mettre √† jour l'affichage
                document.getElementById('timer').textContent = gameState.timeLeft;
                
                // Mettre √† jour la barre de progression
                const timerCircle = document.getElementById('timerCircle');
                const progress = remaining / 12000;
                timerCircle.style.strokeDashoffset = (377 * progress) + 'px';
                
                // Changement de couleur selon le temps restant
                if (gameState.timeLeft <= 5) {
                    timerCircle.className = 'timer-circle warning';
                    document.getElementById('timer').className = 'timer-text warning';
                    
                    if (gameState.timeLeft <= 3) {
                        timerCircle.className = 'timer-circle critical';
                        document.getElementById('timer').className = 'timer-text critical';
                        
                        // Jouer un bip d'avertissement
                        if (gameState.timeLeft === 3) {
                            audioSystem.playBeep('time');
                        }
                    }
                }
                
                // Fin du temps
                if (remaining <= 0) {
                    clearInterval(gameState.timerInterval);
                    handleTimeUp();
                }
            };
            
            // Mettre √† jour imm√©diatement
            updateTimer();
            
            // Mettre √† jour toutes les 100ms pour une pr√©cision maximale
            gameState.timerInterval = setInterval(updateTimer, 100);
        }

        function handleTimeUp() {
            // Jouer le son de fin de temps
            audioSystem.playBeep('wrong');
            
            showNotification('Temps √©coul√© !', 'warning');
            
            // Passer √† la question suivante
            setTimeout(() => {
                if (gameState.currentQuestion < gameState.selectedQuestions) {
                    const nextQuestionNumber = gameState.currentQuestion + 1;
                    const nextStartTime = syncSystem.getSyncedTime() + 2000; // 2 secondes de d√©lai
                    
                    realTimeManager.startQuestion(nextQuestionNumber);
                    loadQuestion(nextQuestionNumber, nextStartTime);
                } else {
                    endGame();
                }
            }, 2000);
        }

        // ==================== GESTION DES R√âPONSES ====================
        function insertPrefix(prefix) {
            const input = document.getElementById('answerInput');
            input.value = prefix;
            input.focus();
        }

        function submitAnswer() {
            const answer = document.getElementById('answerInput').value.trim();
            const currentQuestion = gameState.questions[gameState.currentQuestion - 1];
            
            if (!answer) {
                showNotification('Veuillez entrer une r√©ponse', 'warning');
                return;
            }
            
            // V√©rifier si la r√©ponse commence par le bon pr√©fixe
            const isCorrect = answer.toLowerCase().startsWith(currentQuestion.prefix.toLowerCase());
            const answerTime = syncSystem.getSyncedTime();
            
            // Enregistrer la r√©ponse
            gameState.answers.push({
                question: gameState.currentQuestion,
                answer: answer,
                correct: isCorrect,
                time: answerTime,
                timeSpent: answerTime - gameState.questionStartTime
            });
            
            // Mettre √† jour le score
            if (isCorrect) {
                // Calculer les points bas√©s sur la vitesse
                const timeSpent = answerTime - gameState.questionStartTime;
                const points = calculatePoints(timeSpent);
                
                gameState.score += points;
                document.getElementById('playerScore').textContent = gameState.score;
                
                // Effet visuel
                document.getElementById('answerInput').className = 'answer-input correct';
                audioSystem.playBeep('correct');
                
                // Notification
                showNotification(`Bonne r√©ponse ! +${points} points`, 'success');
                
                // Mettre √† jour le classement
                updateScoreWithSimulatedPlayers(points);
                
            } else {
                // Mauvaise r√©ponse
                document.getElementById('answerInput').className = 'answer-input incorrect';
                audioSystem.playBeep('wrong');
                
                showNotification('Mauvaise r√©ponse', 'error');
            }
            
            // D√©sactiver l'entr√©e
            document.getElementById('answerInput').disabled = true;
            document.getElementById('submitAnswerBtn').disabled = true;
            
            // Passer √† la question suivante apr√®s un d√©lai
            setTimeout(() => {
                if (gameState.currentQuestion < gameState.selectedQuestions) {
                    const nextQuestionNumber = gameState.currentQuestion + 1;
                    const nextStartTime = syncSystem.getSyncedTime() + 1500; // 1.5 seconde de d√©lai
                    
                    realTimeManager.startQuestion(nextQuestionNumber);
                    loadQuestion(nextQuestionNumber, nextStartTime);
                    
                    // R√©activer l'entr√©e
                    document.getElementById('answerInput').disabled = false;
                    document.getElementById('submitAnswerBtn').disabled = false;
                } else {
                    endGame();
                }
            }, isCorrect ? 1500 : 2000);
        }

        function calculatePoints(timeSpent) {
            // 10 points maximum, moins si plus lent
            const maxTime = 12000; // 12 secondes
            const basePoints = 10;
            
            // Points d√©croissants avec le temps
            const timeFactor = Math.max(0, (maxTime - timeSpent) / maxTime);
            const points = Math.ceil(basePoints * timeFactor);
            
            return Math.max(1, points); // Minimum 1 point
        }

        // ==================== CLASSEMENT ====================
        function updateScoreboard(players) {
            const scoreboard = document.getElementById('scoreboard');
            if (!scoreboard) return;
            
            // Trier par score
            players.sort((a, b) => b.score - a.score);
            
            scoreboard.innerHTML = '';
            
            players.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'score-item';
                if (player.id === gameState.playerId) item.classList.add('current');
                if (index === 0) item.classList.add('leading');
                
                item.innerHTML = `
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-name">${player.name} ${player.isHost ? 'üëë' : ''}</div>
                    <div class="player-score">${player.score}</div>
                `;
                
                scoreboard.appendChild(item);
            });
        }

        function updateScoreWithSimulatedPlayers(playerPoints) {
            // Simuler les r√©ponses des autres joueurs
            const players = [
                {id: 'host', name: 'H√¥te', score: gameState.isHost ? gameState.score : Math.floor(Math.random() * 100), isHost: true},
                {id: gameState.playerId, name: gameState.playerName, score: gameState.score, isHost: false},
                {id: 'player2', name: 'Alex', score: Math.floor(Math.random() * 120), isHost: false},
                {id: 'player3', name: 'Sam', score: Math.floor(Math.random() * 90), isHost: false},
                {id: 'player4', name: 'Jordan', score: Math.floor(Math.random() * 70), isHost: false}
            ];
            
            // Ajouter des points al√©atoires pour simuler l'activit√©
            players.forEach(player => {
                if (player.id !== gameState.playerId && Math.random() > 0.3) {
                    player.score += Math.floor(Math.random() * 10);
                }
            });
            
            updateScoreboard(players);
        }

        // ==================== FIN DE PARTIE ====================
        function endGame() {
            clearInterval(gameState.timerInterval);
            realTimeManager.stopBroadcasting();
            
            // Calculer les statistiques
            const totalTime = Date.now() - gameState.gameStartTime;
            const correctAnswers = gameState.answers.filter(a => a.correct).length;
            const accuracy = gameState.answers.length > 0 ? 
                Math.round((correctAnswers / gameState.answers.length) * 100) : 0;
            
            // Simuler les r√©sultats finaux
            const players = [
                {name: gameState.playerName, score: gameState.score, correct: correctAnswers},
                {name: 'Alex', score: Math.floor(Math.random() * 150), correct: Math.floor(Math.random() * 8)},
                {name: 'Sam', score: Math.floor(Math.random() * 120), correct: Math.floor(Math.random() * 7)},
                {name: 'Jordan', score: Math.floor(Math.random() * 90), correct: Math.floor(Math.random() * 6)}
            ];
            
            // Trier par score
            players.sort((a, b) => b.score - a.score);
            
            // Afficher les r√©sultats
            displayResults(players, totalTime, accuracy);
            
            // Jouer le son de fin
            audioSystem.playBeep('correct');
            
            showScreen('resultsScreen');
        }

        function displayResults(players, totalTime, accuracy) {
            const winner = players[0];
            
            // Mettre √† jour l'interface
            document.getElementById('winnerName').textContent = winner.name;
            document.getElementById('winnerScore').textContent = winner.score + ' points';
            document.getElementById('winnerStats').textContent = 
                `${winner.correct} bonnes r√©ponses ‚Ä¢ ${accuracy}% de pr√©cision`;
            
            document.getElementById('totalQuestionsPlayed').textContent = gameState.selectedQuestions;
            document.getElementById('totalPlayers').textContent = players.length;
            document.getElementById('gameDuration').textContent = Math.round(totalTime / 1000) + 's';
            
            // Afficher le classement final
            const finalScoreboard = document.getElementById('finalScoreboard');
            finalScoreboard.innerHTML = '';
            
            players.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'score-item';
                if (index === 0) item.classList.add('leading');
                if (player.name === gameState.playerName) item.classList.add('current');
                
                item.innerHTML = `
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-score">${player.score}</div>
                    <div class="score-change positive">${player.correct}‚úì</div>
                `;
                
                finalScoreboard.appendChild(item);
            });
        }

        // ==================== REJOUER ====================
        function playAgain() {
            if (gameState.isHost) {
                // L'h√¥te peut relancer une partie
                gameState.score = 0;
                gameState.currentQuestion = 1;
                gameState.answers = [];
                startGame();
            } else {
                // Les autres retournent √† l'attente
                showScreen('waitingScreen');
            }
        }

        // ==================== QUITTER ====================
        function leaveRoom() {
            gameState.roomCode = null;
            gameState.isHost = false;
            gameState.gameStarted = false;
            
            realTimeManager.stopBroadcasting();
            realTimeManager.roomCode = null;
            
            showScreen('homeScreen');
            showNotification('Salle quitt√©e', 'info');
        }

        // ==================== MESSAGES SERVEUR ====================
        function handleServerMessage(event) {
            const data = event.detail;
            
            switch(data.type) {
                case 'game_state':
                    handleGameStateUpdate(data);
                    break;
                    
                case 'question_start':
                    handleQuestionStart(data);
                    break;
                    
                case 'player_action':
                    handlePlayerAction(data);
                    break;
            }
        }

        function handleGameStateUpdate(data) {
            // Mettre √† jour l'√©tat du jeu depuis le serveur
            if (data.roomCode === gameState.roomCode) {
                // Synchroniser le timer
                if (data.questionStartTime && data.timeRemaining) {
                    const serverTimeRemaining = data.timeRemaining;
                    const localTimeRemaining = realTimeManager.getTimeRemaining();
                    
                    // Ajuster si la diff√©rence est significative
                    if (Math.abs(serverTimeRemaining - localTimeRemaining) > 500) {
                        console.log('Ajustement de synchronisation du timer');
                        gameState.questionStartTime = syncSystem.serverToClientTime(data.questionStartTime);
                    }
                }
                
                // Mettre √† jour les joueurs
                if (data.players) {
                    updatePlayerDisplay(data.players);
                }
            }
        }

        function handleQuestionStart(data) {
            if (data.roomCode === gameState.roomCode) {
                // D√©marrer la question avec le temps synchronis√©
                const clientStartTime = syncSystem.serverToClientTime(data.startTime);
                loadQuestion(data.questionNumber, clientStartTime);
            }
        }

        function handlePlayerAction(data) {
            // Mettre √† jour l'interface avec les actions des autres joueurs
            if (data.playerId !== gameState.playerId) {
                showNotification(`${data.playerId} a r√©pondu ${data.correct ? 'correctement' : 'incorrectement'}`, 'info');
                
                // Mettre √† jour le classement
                updateScoreWithSimulatedPlayers(data.correct ? 10 : 0);
            }
        }

        function updatePlayerDisplay(players) {
            // Mettre √† jour les listes de joueurs
            const playerList = players.map(p => ({
                id: p.id,
                name: p.name,
                score: p.score || 0,
                isHost: p.isHost || false,
                answered: p.answered || false
            }));
            
            updatePlayerList(playerList, 'waitingPlayersList');
            updatePlayerList(playerList, 'playersListCreate');
        }

        // ==================== LISTE DES JOUEURS ====================
        function updatePlayerList(players, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            players.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player';
                if (player.isHost) div.classList.add('host');
                if (player.answered) div.classList.add('answered');
                
                div.innerHTML = `
                    <i class="fas ${player.isHost ? 'fa-crown' : 'fa-user'}"></i>
                    <span>${player.name}</span>
                    ${player.score !== undefined ? `<span style="margin-left: auto; font-weight: 700;">${player.score}</span>` : ''}
                `;
                
                container.appendChild(div);
            });
        }

        // ==================== VISIBILIT√â ====================
        function handleVisibilityChange() {
            if (document.hidden) {
                // Page cach√©e
                setTimeout(() => {
                    if (document.hidden) {
                        document.getElementById('statusDot').classList.add('offline');
                        document.getElementById('statusText').textContent = 'Absent';
                    }
                }, 2000);
            } else {
                // Page visible √† nouveau
                document.getElementById('statusDot').classList.remove('offline');
                document.getElementById('statusText').textContent = 'En ligne';
                
                // Resynchroniser
                syncSystem.syncWithServer();
            }
        }

        // ==================== NOTIFICATIONS ====================
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            
            // Couleur selon le type
            let gradient;
            switch(type) {
                case 'success':
                    gradient = 'linear-gradient(135deg, #10b981, #059669)';
                    break;
                case 'error':
                    gradient = 'linear-gradient(135deg, #ef4444, #dc2626)';
                    break;
                case 'warning':
                    gradient = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    break;
                default:
                    gradient = 'linear-gradient(135deg, #6366f1, #4f46e5)';
            }
            
            notification.style.background = gradient;
            notification.style.borderLeft = `5px solid ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#f59e0b'}`;
            
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 5px;">
                    ${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}
                    ${message}
                </div>
                <div style="font-size: 0.9rem; opacity: 0.9;">
                    ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animation d'entr√©e
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0) scale(1)';
            }, 10);

setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100px) scale(0.9)';
                setTimeout(() => notification.remove(), 300);
            }, 4000);
        }

        function showError(message) {
            const errorDiv = document.getElementById('joinError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // Jouer un son d'erreur
            audioSystem.playBeep('wrong');
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // ==================== STATISTIQUES ====================
        function updateStats() {
            // Simuler des statistiques r√©alistes
            const onlineCount = Math.floor(Math.random() * 500) + 100;
            const gamesPlayed = Math.floor(Math.random() * 10000) + 5000;
            
            document.getElementById('onlineCount').textContent = onlineCount.toLocaleString();
            document.getElementById('gamesPlayed').textContent = gamesPlayed.toLocaleString();
        }

        // ==================== UTILITAIRES ====================
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        // ==================== GESTION DES PR√âFIXES RAPIDES ====================
        function insertPrefix(prefix) {
            const input = document.getElementById('answerInput');
            input.value = prefix;
            input.focus();
            
            // Effet visuel
            input.classList.add('correct');
            setTimeout(() => {
                input.classList.remove('correct');
            }, 300);
        }

        // ==================== INITIALISATION DES SYST√àMES ====================
        function initGameClock() {
            // Horloge de jeu pr√©cise
            setInterval(() => {
                if (gameState.gameStarted && gameState.questionStartTime) {
                    const now = syncSystem.getSyncedTime();
                    const elapsed = now - gameState.questionStartTime;
                    
                    // Mettre √† jour l'interface toutes les 16ms (~60fps)
                    if (elapsed % 16 < 8) { // Optimisation des performances
                        updateGameClock(elapsed);
                    }
                }
            }, 16);
        }

        function updateGameClock(elapsed) {
            const remaining = Math.max(0, 12000 - elapsed);
            const seconds = Math.ceil(remaining / 1000);
            
            // Mettre √† jour uniquement si n√©cessaire
            if (seconds !== gameState.timeLeft) {
                gameState.timeLeft = seconds;
                document.getElementById('timer').textContent = seconds;
                
                // Mettre √† jour la barre de progression
                const progress = remaining / 12000;
                const timerCircle = document.getElementById('timerCircle');
                timerCircle.style.strokeDashoffset = (377 * progress) + 'px';
                
                // G√©rer les changements d'√©tat
                handleTimerState(seconds);
            }
        }

        function handleTimerState(seconds) {
            const timerCircle = document.getElementById('timerCircle');
            const timerText = document.getElementById('timer');
            
            if (seconds <= 5 && seconds > 3) {
                timerCircle.className = 'timer-circle warning';
                timerText.className = 'timer-text warning';
                
                if (seconds === 5) {
                    audioSystem.playBeep('time');
                }
            } else if (seconds <= 3) {
                timerCircle.className = 'timer-circle critical';
                timerText.className = 'timer-text critical';
                
                // Pulsation pour les 3 derni√®res secondes
                if (seconds <= 3 && seconds > 0) {
                    timerText.style.animation = seconds % 2 === 0 ? 'none' : 'pulseCriticalText 0.5s infinite';
                }
            } else {
                timerCircle.className = 'timer-circle';
                timerText.className = 'timer-text';
            }
        }

        // ==================== SYST√àME DE R√âSEAU SIMUL√â ====================
        class NetworkSimulator {
            constructor() {
                this.players = new Map();
                this.messageQueue = [];
                this.networkLatency = 50; // ms de latence moyenne
                this.packetLoss = 0.05; // 5% de perte de paquets
                this.jitter = 20; // Variation de latence
            }
            
            broadcastToRoom(roomCode, message) {
                // Simuler la latence r√©seau
                const latency = this.networkLatency + (Math.random() * 2 - 1) * this.jitter;
                
                setTimeout(() => {
                    // Simuler la perte de paquets
                    if (Math.random() > this.packetLoss) {
                        this.deliverMessage(roomCode, message);
                    }
                }, latency);
            }
            
            deliverMessage(roomCode, message) {
                // Simuler la r√©ception par tous les joueurs de la salle
                window.dispatchEvent(new CustomEvent('network_message', {
                    detail: {
                        roomCode,
                        message,
                        timestamp: Date.now()
                    }
                }));
            }
        }

        const networkSimulator = new NetworkSimulator();

        // ==================== GESTION DES SALES MULTIJOUEURS ====================
        class RoomManager {
            constructor() {
                this.rooms = new Map();
                this.playerRooms = new Map();
            }
            
            createRoom(roomCode, hostId, hostName) {
                const room = {
                    code: roomCode,
                    hostId,
                    players: new Map([[hostId, {
                        id: hostId,
                        name: hostName,
                        score: 0,
                        isHost: true,
                        connected: true,
                        lastActivity: Date.now()
                    }]]),
                    gameState: 'waiting',
                    settings: {
                        questionCount: 10
                    },
                    createdAt: Date.now()
                };
                
                this.rooms.set(roomCode, room);
                this.playerRooms.set(hostId, roomCode);
                
                return room;
            }
            
            joinRoom(roomCode, playerId, playerName) {
                const room = this.rooms.get(roomCode);
                if (!room) return null;
                
                // V√©rifier si la salle est pleine
                if (room.players.size >= 10) return null;
                
                // Ajouter le joueur
                room.players.set(playerId, {
                    id: playerId,
                    name: playerName,
                    score: 0,
                    isHost: false,
                    connected: true,
                    lastActivity: Date.now()
                });
                
                this.playerRooms.set(playerId, roomCode);
                
                // Notifier les autres joueurs
                this.broadcastPlayerUpdate(roomCode);
                
                return room;
            }
            
            broadcastPlayerUpdate(roomCode) {
                const room = this.rooms.get(roomCode);
                if (!room) return;
                
                const players = Array.from(room.players.values());
                
                // Simuler l'envoi r√©seau
                networkSimulator.broadcastToRoom(roomCode, {
                    type: 'players_update',
                    players,
                    timestamp: Date.now()
                });
            }
        }

        const roomManager = new RoomManager();

        // ==================== AM√âLIORATION DE L'EXP√âRIENCE UTILISATEUR ====================
        function enhanceUserExperience() {
            // Pr√©charger les sons
            preloadAudio();
            
            // Optimiser les animations
            optimizeAnimations();
            
            // G√©rer les gestes tactiles
            setupTouchGestures();
        }

        function preloadAudio() {
            // Pr√©charger les sons d'interface
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Cr√©er des bips de pr√©chargement
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            gainNode.gain.value = 0; // Silencieux
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function optimizeAnimations() {
            // D√©tecter les performances
            const canAnimate = 'requestAnimationFrame' in window;
            
            if (!canAnimate) {
                // D√©sactiver les animations complexes
                document.body.classList.add('no-animations');
            }
        }

        function setupTouchGestures() {
            let touchStartY = 0;
            let touchStartX = 0;
            
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
                touchStartX = e.touches[0].clientX;
            });
            
            document.addEventListener('touchend', (e) => {
                const touchEndY = e.changedTouches[0].clientY;
                const touchEndX = e.changedTouches[0].clientX;
                
                const deltaY = touchEndY - touchStartY;
                const deltaX = touchEndX - touchStartX;
                
                // Swipe vers le haut pour rafra√Æchir
                if (deltaY < -50 && Math.abs(deltaX) < 50) {
                    if (document.getElementById('homeScreen').classList.contains('active')) {
                        updateStats();
                        showNotification('Statistiques rafra√Æchies', 'info');
                    }
                }
            });
        }

        // ==================== GESTION DES √âV√âNEMENTS R√âSEAU ====================
        window.addEventListener('network_message', (event) => {
            const { roomCode, message } = event.detail;
            
            if (roomCode === gameState.roomCode) {
                handleNetworkMessage(message);
            }
        });

        function handleNetworkMessage(message) {
            switch(message.type) {
                case 'players_update':
                    updatePlayersList(message.players);
                    break;
                    
                case 'game_start':
                    handleGameStart(message);
                    break;
                    
                case 'question_start':
                    handleSyncedQuestionStart(message);
                    break;
                    
                case 'player_answer':
                    handlePlayerAnswer(message);
                    break;
                    
                case 'game_end':
                    handleGameEnd(message);
                    break;
            }
        }

        function updatePlayersList(players) {
            const waitingList = document.getElementById('waitingPlayersList');
            const createList = document.getElementById('playersListCreate');
            
            if (waitingList) {
                updatePlayerList(players.map(p => ({
                    id: p.id,
                    name: p.name,
                    score: p.score,
                    isHost: p.isHost,
                    answered: false
                })), 'waitingPlayersList');
                
                document.getElementById('playerCountWaiting').textContent = players.length;
            }
            
            if (createList) {
                updatePlayerList(players.map(p => ({
                    id: p.id,
                    name: p.name,
                    score: p.score,
                    isHost: p.isHost,
                    answered: false
                })), 'playersListCreate');
                
                document.getElementById('playerCountCreate').textContent = players.length;
            }
            
            // Mettre √† jour le bouton start si assez de joueurs
            if (gameState.isHost) {
                const startBtn = document.getElementById('startGameBtn');
                if (startBtn) {
                    startBtn.disabled = players.length < 2;
                }
            }
        }

        function handleGameStart(message) {
            if (!gameState.isHost) {
                // Rejoindre la partie d√©marr√©e par l'h√¥te
                gameState.selectedQuestions = message.questionCount;
                gameState.questions = generateQuestions(message.questionCount);
                gameState.gameStarted = true;
                
                showScreen('gameScreen');
                showNotification('La partie commence !', 'success');
                audioSystem.playBeep('start');
            }
        }

        function handleSyncedQuestionStart(message) {
            // Synchroniser le d√©but de la question
            const clientStartTime = syncSystem.serverToClientTime(message.startTime);
            loadQuestion(message.questionNumber, clientStartTime);
        }

        function handlePlayerAnswer(message) {
            // Mettre √† jour le classement avec la r√©ponse d'un autre joueur
            if (message.playerId !== gameState.playerId) {
                // Ajouter une notification
                showNotification(`${message.playerName} a r√©pondu ${message.correct ? 'correctement' : 'incorrectement'}`, 'info');
                
                // Mettre √† jour le scoreboard
                updateScoreWithPlayerAnswer(message.playerId, message.correct ? 10 : 0);
            }
        }

        function updateScoreWithPlayerAnswer(playerId, points) {
            // Simuler la mise √† jour du score d'un autre joueur
            // En r√©alit√©, cela viendrait du serveur
            const playerName = playerId === 'host' ? 'H√¥te' : 'Joueur ' + playerId.substr(-3);
            
            // Mettre √† jour l'affichage
            const scoreboard = document.getElementById('scoreboard');
            if (scoreboard) {
                // Animer la mise √† jour du score
                const items = scoreboard.querySelectorAll('.score-item');
                items.forEach(item => {
                    if (item.querySelector('.player-name').textContent.includes(playerName)) {
                        const scoreElement = item.querySelector('.player-score');
                        const currentScore = parseInt(scoreElement.textContent);
                        const newScore = currentScore + points;
                        
                        scoreElement.textContent = newScore;
                        
                        // Effet visuel
                        const changeElement = document.createElement('div');
                        changeElement.className = `score-change ${points > 0 ? 'positive' : 'negative'}`;
                        changeElement.textContent = points > 0 ? `+${points}` : `${points}`;
                        item.appendChild(changeElement);
                        
                        setTimeout(() => {
                            changeElement.remove();
                        }, 1000);
                    }
                });
            }
        }

        function handleGameEnd(message) {
            if (!gameState.isHost) {
                // Afficher les r√©sultats finaux
                displayResults(message.results, message.totalTime, message.accuracy);
                showScreen('resultsScreen');
            }
        }

        // ==================== GESTION DE LA BATTERIE ET PERFORMANCES ====================
        function setupPerformanceMonitoring() {
            // Surveiller la m√©moire
            if ('memory' in performance) {
                setInterval(() => {
                    const usedMB = performance.memory.usedJSHeapSize / (1024 * 1024);
                    if (usedMB > 100) {
                        // Nettoyer si utilisation m√©moire √©lev√©e
                        cleanupMemory();
                    }
                }, 30000);
            }
            
            // Surveiller la batterie
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    battery.addEventListener('levelchange', () => {
                        if (battery.level < 0.2) {
                            // Mode √©conomie d'√©nergie
                            enablePowerSavingMode();
                        }
                    });
                });
            }
        }

        function cleanupMemory() {
            // Nettoyer les donn√©es temporaires
            audioSystem.stopSpeaking();
            clearInterval(gameState.timerInterval);
            
            // Forcer le garbage collection si disponible
            if (window.gc) {
                window.gc();
            }
        }

        function enablePowerSavingMode() {
            // R√©duire les animations
            document.body.classList.add('power-saving');
            
            // D√©sactiver certaines fonctionnalit√©s
            gameState.voiceEnabled = false;
            updateVoiceButtons(false);
            
            showNotification('Mode √©conomie d\'√©nergie activ√©', 'warning');
        }

        // ==================== SAUVEGARDE ET R√âCUP√âRATION ====================
        function setupAutoSave() {
            // Sauvegarder l'√©tat p√©riodiquement
            setInterval(() => {
                if (gameState.roomCode || gameState.gameStarted) {
                    saveGameState();
                }
            }, 30000);
            
            // Sauvegarder avant de quitter
            window.addEventListener('beforeunload', saveGameState);
            
            // Essayer de r√©cup√©rer l'√©tat sauvegard√©
            try {
                const saved = localStorage.getItem('quizLastState');
                if (saved) {
                    const state = JSON.parse(saved);
                    if (Date.now() - state.timestamp < 300000) { // 5 minutes
                        showNotification('Partie pr√©c√©dente restaur√©e', 'info');
                    }
                }
            } catch (e) {
                console.log('Aucun √©tat pr√©c√©dent √† restaurer');
            }
        }

        function saveGameState() {
            const state = {
                playerName: gameState.playerName,
                roomCode: gameState.roomCode,
                isHost: gameState.isHost,
                score: gameState.score,
                currentQuestion: gameState.currentQuestion,
                questions: gameState.questions,
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem('quizLastState', JSON.stringify(state));
            } catch (e) {
                console.warn('Impossible de sauvegarder l\'√©tat');
            }
        }

        // ==================== INITIALISATION FINALE ====================
        function finalInit() {
            // D√©marrer tous les syst√®mes
            initGameClock();
            enhanceUserExperience();
            setupPerformanceMonitoring();
            setupAutoSave();
            
            // V√©rifier la connexion internet
            checkConnection();
            
            // D√©marrer avec une petite animation de bienvenue
            setTimeout(() => {
                if (document.getElementById('homeScreen').classList.contains('active')) {
                    audioSystem.playBeep('start');
                }
            }, 1000);
        }

        function checkConnection() {
            const online = navigator.onLine;
            if (!online) {
                showNotification('Mode hors ligne activ√©', 'warning');
                gameState.connected = false;
                updateConnectionStatus(false);
            }
        }

        function updateConnectionStatus(connected) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.classList.remove('offline');
                statusText.textContent = 'En ligne';
                statusText.style.color = '#10b981';
            } else {
                statusDot.classList.add('offline');
                statusText.textContent = 'Hors ligne';
                statusText.style.color = '#ef4444';
            }
            
            gameState.connected = connected;
        }

        // ==================== LANCEMENT DE L'APPLICATION ====================
        // Attendre que tout soit charg√©
        window.addEventListener('load', () => {
            // D√©marrer l'application
            finalInit();
            
            // Afficher les instructions si premier d√©marrage
            if (!localStorage.getItem('quizFirstLaunch')) {
                setTimeout(() => {
                    showNotification('üëã Bienvenue ! Cr√©ez ou rejoignez une salle pour jouer', 'info');
                    localStorage.setItem('quizFirstLaunch', 'true');
                }, 2000);
            }
        });

        // Exporter certaines fonctions pour le d√©bogage
        window.quizDebug = {
            getGameState: () => ({...gameState}),
            getSyncStatus: () => syncSystem,
            getAudioStatus: () => audioSystem,
            testSync: () => syncSystem.syncWithServer(),
            testAudio: () => audioSystem.testAudio(),
            resetGame: () => {
                gameState = {
                    playerId: 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    playerName: gameState.playerName,
                    roomCode: null,
                    isHost: false,
                    selectedQuestions: 10,
                    currentQuestion: 1,
                    score: 0,
                    connected: true,
                    voiceEnabled: true,
                    questions: [],
                    players: {},
                    timerInterval: null,
                    timeLeft: 12,
                    questionStartTime: 0,
                    lastAnswerTime: 0,
                    syncStatus: 'syncing',
                    gameStarted: false,
                    answers: []
                };
                showScreen('homeScreen');
            }
        };

        // Code final - tout est initialis√©
        console.log('üéÆ Quiz Multijoueur - Syst√®me de synchronisation temps r√©el pr√™t !');
    </script>
</body>
</html>

            


